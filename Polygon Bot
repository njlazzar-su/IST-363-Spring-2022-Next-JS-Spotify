{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/njlazzar-su/IST-363-Spring-2022-Next-JS-Spotify/blob/main/Polygon%20Bot\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "WuzP92TCiten",
        "outputId": "464bfcd8-0d54-4267-a8b5-e24d788dbc20"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Collecting web3\n",
            "  Downloading web3-7.2.0-py3-none-any.whl.metadata (5.0 kB)\n",
            "Collecting eth-abi>=5.0.1 (from web3)\n",
            "  Downloading eth_abi-5.1.0-py3-none-any.whl.metadata (5.1 kB)\n",
            "Collecting eth-account>=0.13.1 (from web3)\n",
            "  Downloading eth_account-0.13.3-py3-none-any.whl.metadata (5.3 kB)\n",
            "Collecting eth-hash>=0.5.1 (from eth-hash[pycryptodome]>=0.5.1->web3)\n",
            "  Downloading eth_hash-0.7.0-py3-none-any.whl.metadata (5.4 kB)\n",
            "Collecting eth-typing>=5.0.0 (from web3)\n",
            "  Downloading eth_typing-5.0.0-py3-none-any.whl.metadata (5.1 kB)\n",
            "Collecting eth-utils>=5.0.0 (from web3)\n",
            "  Downloading eth_utils-5.0.0-py3-none-any.whl.metadata (5.4 kB)\n",
            "Collecting hexbytes>=1.2.0 (from web3)\n",
            "  Downloading hexbytes-1.2.1-py3-none-any.whl.metadata (3.7 kB)\n",
            "Requirement already satisfied: aiohttp>=3.7.4.post0 in /usr/local/lib/python3.10/dist-packages (from web3) (3.10.5)\n",
            "Requirement already satisfied: pydantic>=2.4.0 in /usr/local/lib/python3.10/dist-packages (from web3) (2.8.2)\n",
            "Requirement already satisfied: requests>=2.23.0 in /usr/local/lib/python3.10/dist-packages (from web3) (2.32.3)\n",
            "Requirement already satisfied: typing-extensions>=4.0.1 in /usr/local/lib/python3.10/dist-packages (from web3) (4.12.2)\n",
            "Collecting types-requests>=2.0.0 (from web3)\n",
            "  Downloading types_requests-2.32.0.20240907-py3-none-any.whl.metadata (1.9 kB)\n",
            "Collecting websockets>=10.0.0 (from web3)\n",
            "  Downloading websockets-13.0.1-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (6.7 kB)\n",
            "Collecting pyunormalize>=15.0.0 (from web3)\n",
            "  Downloading pyunormalize-15.1.0.tar.gz (515 kB)\n",
            "\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m515.5/515.5 kB\u001b[0m \u001b[31m8.3 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25h  Preparing metadata (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "Requirement already satisfied: aiohappyeyeballs>=2.3.0 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (2.4.0)\n",
            "Requirement already satisfied: aiosignal>=1.1.2 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (1.3.1)\n",
            "Requirement already satisfied: attrs>=17.3.0 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (24.2.0)\n",
            "Requirement already satisfied: frozenlist>=1.1.1 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (1.4.1)\n",
            "Requirement already satisfied: multidict<7.0,>=4.5 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (6.0.5)\n",
            "Requirement already satisfied: yarl<2.0,>=1.0 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (1.9.4)\n",
            "Requirement already satisfied: async-timeout<5.0,>=4.0 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (4.0.3)\n",
            "Collecting parsimonious<0.11.0,>=0.10.0 (from eth-abi>=5.0.1->web3)\n",
            "  Downloading parsimonious-0.10.0-py3-none-any.whl.metadata (25 kB)\n",
            "Collecting bitarray>=2.4.0 (from eth-account>=0.13.1->web3)\n",
            "  Downloading bitarray-2.9.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (34 kB)\n",
            "Collecting eth-keyfile>=0.7.0 (from eth-account>=0.13.1->web3)\n",
            "  Downloading eth_keyfile-0.8.1-py3-none-any.whl.metadata (8.5 kB)\n",
            "Collecting eth-keys>=0.4.0 (from eth-account>=0.13.1->web3)\n",
            "  Downloading eth_keys-0.5.1-py3-none-any.whl.metadata (13 kB)\n",
            "Collecting eth-rlp>=2.1.0 (from eth-account>=0.13.1->web3)\n",
            "  Downloading eth_rlp-2.1.0-py3-none-any.whl.metadata (4.6 kB)\n",
            "Collecting rlp>=1.0.0 (from eth-account>=0.13.1->web3)\n",
            "  Downloading rlp-4.0.1-py3-none-any.whl.metadata (4.6 kB)\n",
            "Collecting ckzg>=2.0.0 (from eth-account>=0.13.1->web3)\n",
            "  Downloading ckzg-2.0.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (683 bytes)\n",
            "Collecting pycryptodome<4,>=3.6.6 (from eth-hash[pycryptodome]>=0.5.1->web3)\n",
            "  Downloading pycryptodome-3.20.0-cp35-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.4 kB)\n",
            "Collecting cytoolz>=0.10.1 (from eth-utils>=5.0.0->web3)\n",
            "  Downloading cytoolz-0.12.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (4.6 kB)\n",
            "Requirement already satisfied: annotated-types>=0.4.0 in /usr/local/lib/python3.10/dist-packages (from pydantic>=2.4.0->web3) (0.7.0)\n",
            "Requirement already satisfied: pydantic-core==2.20.1 in /usr/local/lib/python3.10/dist-packages (from pydantic>=2.4.0->web3) (2.20.1)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->web3) (3.3.2)\n",
            "Requirement already satisfied: idna<4,>=2.5 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->web3) (3.8)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->web3) (2.0.7)\n",
            "Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->web3) (2024.8.30)\n",
            "Requirement already satisfied: toolz>=0.8.0 in /usr/local/lib/python3.10/dist-packages (from cytoolz>=0.10.1->eth-utils>=5.0.0->web3) (0.12.1)\n",
            "Requirement already satisfied: regex>=2022.3.15 in /usr/local/lib/python3.10/dist-packages (from parsimonious<0.11.0,>=0.10.0->eth-abi>=5.0.1->web3) (2024.5.15)\n",
            "Downloading web3-7.2.0-py3-none-any.whl (1.3 MB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m1.3/1.3 MB\u001b[0m \u001b[31m34.8 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading eth_abi-5.1.0-py3-none-any.whl (29 kB)\n",
            "Downloading eth_account-0.13.3-py3-none-any.whl (580 kB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m580.1/580.1 kB\u001b[0m \u001b[31m24.2 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading eth_hash-0.7.0-py3-none-any.whl (8.7 kB)\n",
            "Downloading eth_typing-5.0.0-py3-none-any.whl (20 kB)\n",
            "Downloading eth_utils-5.0.0-py3-none-any.whl (100 kB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m100.5/100.5 kB\u001b[0m \u001b[31m5.0 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading hexbytes-1.2.1-py3-none-any.whl (5.2 kB)\n",
            "Downloading types_requests-2.32.0.20240907-py3-none-any.whl (15 kB)\n",
            "Downloading websockets-13.0.1-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl (157 kB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m157.3/157.3 kB\u001b[0m \u001b[31m11.3 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading bitarray-2.9.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (288 kB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m288.3/288.3 kB\u001b[0m \u001b[31m17.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading ckzg-2.0.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (168 kB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m168.9/168.9 kB\u001b[0m \u001b[31m10.0 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading cytoolz-0.12.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (2.0 MB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m2.0/2.0 MB\u001b[0m \u001b[31m51.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading eth_keyfile-0.8.1-py3-none-any.whl (7.5 kB)\n",
            "Downloading eth_keys-0.5.1-py3-none-any.whl (21 kB)\n",
            "Downloading eth_rlp-2.1.0-py3-none-any.whl (5.1 kB)\n",
            "Downloading parsimonious-0.10.0-py3-none-any.whl (48 kB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m48.4/48.4 kB\u001b[0m \u001b[31m2.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading pycryptodome-3.20.0-cp35-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (2.1 MB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m2.1/2.1 MB\u001b[0m \u001b[31m55.1 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading rlp-4.0.1-py3-none-any.whl (20 kB)\n",
            "Building wheels for collected packages: pyunormalize\n",
            "  Building wheel for pyunormalize (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "  Created wheel for pyunormalize: filename=pyunormalize-15.1.0-py3-none-any.whl size=516031 sha256=b09c95f7d241e0aef8174f3e2d7d3aa5aabcc31a0f94d7bb3942345a4e8e7a3b\n",
            "  Stored in directory: /root/.cache/pip/wheels/b8/b6/c6/6fc11f58d3fd02f387cf3b18479bb5c6d4143995d0fa401622\n",
            "Successfully built pyunormalize\n",
            "Installing collected packages: ckzg, bitarray, websockets, types-requests, pyunormalize, pycryptodome, parsimonious, hexbytes, eth-typing, eth-hash, cytoolz, eth-utils, rlp, eth-keys, eth-abi, eth-rlp, eth-keyfile, eth-account, web3\n",
            "Successfully installed bitarray-2.9.2 ckzg-2.0.1 cytoolz-0.12.3 eth-abi-5.1.0 eth-account-0.13.3 eth-hash-0.7.0 eth-keyfile-0.8.1 eth-keys-0.5.1 eth-rlp-2.1.0 eth-typing-5.0.0 eth-utils-5.0.0 hexbytes-1.2.1 parsimonious-0.10.0 pycryptodome-3.20.0 pyunormalize-15.1.0 rlp-4.0.1 types-requests-2.32.0.20240907 web3-7.2.0 websockets-13.0.1\n"
          ]
        }
      ],
      "source": [
        "pip install web3"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "Q3al9ZqJjFyl",
        "outputId": "de5138ea-60f6-48b6-b1d4-42bff9c102f0"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Requirement already satisfied: web3 in /usr/local/lib/python3.10/dist-packages (7.2.0)\n",
            "Requirement already satisfied: eth-account in /usr/local/lib/python3.10/dist-packages (0.13.3)\n",
            "Requirement already satisfied: eth-abi>=5.0.1 in /usr/local/lib/python3.10/dist-packages (from web3) (5.1.0)\n",
            "Requirement already satisfied: eth-hash>=0.5.1 in /usr/local/lib/python3.10/dist-packages (from eth-hash[pycryptodome]>=0.5.1->web3) (0.7.0)\n",
            "Requirement already satisfied: eth-typing>=5.0.0 in /usr/local/lib/python3.10/dist-packages (from web3) (5.0.0)\n",
            "Requirement already satisfied: eth-utils>=5.0.0 in /usr/local/lib/python3.10/dist-packages (from web3) (5.0.0)\n",
            "Requirement already satisfied: hexbytes>=1.2.0 in /usr/local/lib/python3.10/dist-packages (from web3) (1.2.1)\n",
            "Requirement already satisfied: aiohttp>=3.7.4.post0 in /usr/local/lib/python3.10/dist-packages (from web3) (3.10.5)\n",
            "Requirement already satisfied: pydantic>=2.4.0 in /usr/local/lib/python3.10/dist-packages (from web3) (2.8.2)\n",
            "Requirement already satisfied: requests>=2.23.0 in /usr/local/lib/python3.10/dist-packages (from web3) (2.32.3)\n",
            "Requirement already satisfied: typing-extensions>=4.0.1 in /usr/local/lib/python3.10/dist-packages (from web3) (4.12.2)\n",
            "Requirement already satisfied: types-requests>=2.0.0 in /usr/local/lib/python3.10/dist-packages (from web3) (2.32.0.20240907)\n",
            "Requirement already satisfied: websockets>=10.0.0 in /usr/local/lib/python3.10/dist-packages (from web3) (13.0.1)\n",
            "Requirement already satisfied: pyunormalize>=15.0.0 in /usr/local/lib/python3.10/dist-packages (from web3) (15.1.0)\n",
            "Requirement already satisfied: bitarray>=2.4.0 in /usr/local/lib/python3.10/dist-packages (from eth-account) (2.9.2)\n",
            "Requirement already satisfied: eth-keyfile>=0.7.0 in /usr/local/lib/python3.10/dist-packages (from eth-account) (0.8.1)\n",
            "Requirement already satisfied: eth-keys>=0.4.0 in /usr/local/lib/python3.10/dist-packages (from eth-account) (0.5.1)\n",
            "Requirement already satisfied: eth-rlp>=2.1.0 in /usr/local/lib/python3.10/dist-packages (from eth-account) (2.1.0)\n",
            "Requirement already satisfied: rlp>=1.0.0 in /usr/local/lib/python3.10/dist-packages (from eth-account) (4.0.1)\n",
            "Requirement already satisfied: ckzg>=2.0.0 in /usr/local/lib/python3.10/dist-packages (from eth-account) (2.0.1)\n",
            "Requirement already satisfied: aiohappyeyeballs>=2.3.0 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (2.4.0)\n",
            "Requirement already satisfied: aiosignal>=1.1.2 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (1.3.1)\n",
            "Requirement already satisfied: attrs>=17.3.0 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (24.2.0)\n",
            "Requirement already satisfied: frozenlist>=1.1.1 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (1.4.1)\n",
            "Requirement already satisfied: multidict<7.0,>=4.5 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (6.0.5)\n",
            "Requirement already satisfied: yarl<2.0,>=1.0 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (1.9.4)\n",
            "Requirement already satisfied: async-timeout<5.0,>=4.0 in /usr/local/lib/python3.10/dist-packages (from aiohttp>=3.7.4.post0->web3) (4.0.3)\n",
            "Requirement already satisfied: parsimonious<0.11.0,>=0.10.0 in /usr/local/lib/python3.10/dist-packages (from eth-abi>=5.0.1->web3) (0.10.0)\n",
            "Requirement already satisfied: pycryptodome<4,>=3.6.6 in /usr/local/lib/python3.10/dist-packages (from eth-hash[pycryptodome]>=0.5.1->web3) (3.20.0)\n",
            "Requirement already satisfied: cytoolz>=0.10.1 in /usr/local/lib/python3.10/dist-packages (from eth-utils>=5.0.0->web3) (0.12.3)\n",
            "Requirement already satisfied: annotated-types>=0.4.0 in /usr/local/lib/python3.10/dist-packages (from pydantic>=2.4.0->web3) (0.7.0)\n",
            "Requirement already satisfied: pydantic-core==2.20.1 in /usr/local/lib/python3.10/dist-packages (from pydantic>=2.4.0->web3) (2.20.1)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->web3) (3.3.2)\n",
            "Requirement already satisfied: idna<4,>=2.5 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->web3) (3.8)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->web3) (2.0.7)\n",
            "Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->web3) (2024.8.30)\n",
            "Requirement already satisfied: toolz>=0.8.0 in /usr/local/lib/python3.10/dist-packages (from cytoolz>=0.10.1->eth-utils>=5.0.0->web3) (0.12.1)\n",
            "Requirement already satisfied: regex>=2022.3.15 in /usr/local/lib/python3.10/dist-packages (from parsimonious<0.11.0,>=0.10.0->eth-abi>=5.0.1->web3) (2024.5.15)\n"
          ]
        }
      ],
      "source": [
        "pip install web3 eth-account"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 6,
      "metadata": {
        "id": "RRT4dzMsiasX"
      },
      "outputs": [],
      "source": [
        "import telebot\n",
        "from web3 import Web3\n",
        "from eth_account import Account\n",
        "import requests\n",
        "import time\n",
        "from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton, BotCommand\n",
        "from telebot import types\n",
        "import os\n",
        "import json\n",
        "from decimal import Decimal\n",
        "\n",
        "from google.colab import userdata\n",
        "\n",
        "\n",
        "# Initialize Web3\n",
        "polygon_rpc_url = \"https://polygon-mainnet.infura.io/v3/30722cdc5c074cea8cdacdeb200a3da4\"\n",
        "web3 = Web3(Web3.HTTPProvider(polygon_rpc_url))\n",
        "\n",
        "# Polygonscan API Key\n",
        "polygonscan_api_key = userdata.get('polyscan_api')  # Replace with your Polygonscan API key\n",
        "\n",
        "\n",
        "# Router contract (e.g., Uniswap or Sushiswap)\n",
        "router_contract_address = \"0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff\"\n",
        "router_abi = [\n",
        "    {\n",
        "        \"inputs\": [],\n",
        "        \"name\": \"WETH\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"\",\n",
        "                \"type\": \"address\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"pure\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"tokenA\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"tokenB\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountADesired\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountBDesired\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountAMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountBMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"addLiquidity\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountA\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountB\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"liquidity\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"token\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountTokenDesired\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountTokenMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETHMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"addLiquidityETH\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountToken\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETH\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"liquidity\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"payable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [],\n",
        "        \"name\": \"factory\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"\",\n",
        "                \"type\": \"address\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"pure\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOut\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"reserveIn\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"reserveOut\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"getAmountIn\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountIn\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"pure\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountIn\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"reserveIn\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"reserveOut\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"getAmountOut\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOut\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"pure\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOut\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"getAmountsIn\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256[]\",\n",
        "                \"name\": \"amounts\",\n",
        "                \"type\": \"uint256[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"view\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountIn\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"getAmountsOut\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256[]\",\n",
        "                \"name\": \"amounts\",\n",
        "                \"type\": \"uint256[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"view\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountA\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"reserveA\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"reserveB\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"quote\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountB\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"pure\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"tokenA\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"tokenB\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"liquidity\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountAMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountBMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"removeLiquidity\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountA\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountB\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"token\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"liquidity\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountTokenMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETHMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"removeLiquidityETH\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountToken\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETH\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"token\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"liquidity\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountTokenMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETHMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"removeLiquidityETHSupportingFeeOnTransferTokens\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETH\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"token\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"liquidity\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountTokenMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETHMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"bool\",\n",
        "                \"name\": \"approveMax\",\n",
        "                \"type\": \"bool\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint8\",\n",
        "                \"name\": \"v\",\n",
        "                \"type\": \"uint8\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"bytes32\",\n",
        "                \"name\": \"r\",\n",
        "                \"type\": \"bytes32\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"bytes32\",\n",
        "                \"name\": \"s\",\n",
        "                \"type\": \"bytes32\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"removeLiquidityETHWithPermit\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountToken\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETH\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"token\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"liquidity\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountTokenMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETHMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"bool\",\n",
        "                \"name\": \"approveMax\",\n",
        "                \"type\": \"bool\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint8\",\n",
        "                \"name\": \"v\",\n",
        "                \"type\": \"uint8\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"bytes32\",\n",
        "                \"name\": \"r\",\n",
        "                \"type\": \"bytes32\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"bytes32\",\n",
        "                \"name\": \"s\",\n",
        "                \"type\": \"bytes32\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountETH\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"tokenA\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"tokenB\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"liquidity\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountAMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountBMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"bool\",\n",
        "                \"name\": \"approveMax\",\n",
        "                \"type\": \"bool\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint8\",\n",
        "                \"name\": \"v\",\n",
        "                \"type\": \"uint8\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"bytes32\",\n",
        "                \"name\": \"r\",\n",
        "                \"type\": \"bytes32\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"bytes32\",\n",
        "                \"name\": \"s\",\n",
        "                \"type\": \"bytes32\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"removeLiquidityWithPermit\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountA\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountB\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOut\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"swapETHForExactTokens\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256[]\",\n",
        "                \"name\": \"amounts\",\n",
        "                \"type\": \"uint256[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"payable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOutMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"swapExactETHForTokens\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256[]\",\n",
        "                \"name\": \"amounts\",\n",
        "                \"type\": \"uint256[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"payable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOutMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"swapExactETHForTokensSupportingFeeOnTransferTokens\",\n",
        "        \"outputs\": [],\n",
        "        \"stateMutability\": \"payable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountIn\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOutMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"swapExactTokensForETH\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256[]\",\n",
        "                \"name\": \"amounts\",\n",
        "                \"type\": \"uint256[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountIn\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOutMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"swapExactTokensForETHSupportingFeeOnTransferTokens\",\n",
        "        \"outputs\": [],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountIn\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOutMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"swapExactTokensForTokens\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256[]\",\n",
        "                \"name\": \"amounts\",\n",
        "                \"type\": \"uint256[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountIn\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOutMin\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\n",
        "        \"outputs\": [],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOut\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountInMax\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"swapTokensForExactETH\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256[]\",\n",
        "                \"name\": \"amounts\",\n",
        "                \"type\": \"uint256[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    },\n",
        "    {\n",
        "        \"inputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountOut\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"amountInMax\",\n",
        "                \"type\": \"uint256\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address[]\",\n",
        "                \"name\": \"path\",\n",
        "                \"type\": \"address[]\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"address\",\n",
        "                \"name\": \"to\",\n",
        "                \"type\": \"address\"\n",
        "            },\n",
        "            {\n",
        "                \"internalType\": \"uint256\",\n",
        "                \"name\": \"deadline\",\n",
        "                \"type\": \"uint256\"\n",
        "            }\n",
        "        ],\n",
        "        \"name\": \"swapTokensForExactTokens\",\n",
        "        \"outputs\": [\n",
        "            {\n",
        "                \"internalType\": \"uint256[]\",\n",
        "                \"name\": \"amounts\",\n",
        "                \"type\": \"uint256[]\"\n",
        "            }\n",
        "        ],\n",
        "        \"stateMutability\": \"nonpayable\",\n",
        "        \"type\": \"function\"\n",
        "    }\n",
        "]\n",
        "  # Add router ABI here\n",
        "router_contract = web3.eth.contract(address=router_contract_address, abi=router_abi)\n",
        "\n",
        "tax_wallet_address = \"0x1bba932b2834Bd030B6A7EeB88f8842aD9bC11d4\"  # Replace with the actual wallet address\n",
        "\n",
        "# Token addresses\n",
        "wmatic_address = \"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\"\n",
        "\n",
        "# Initialize the bot\n",
        "bot_token = userdata.get('bot_api')\n",
        "bot = telebot.TeleBot(bot_token)\n",
        "\n",
        "def escape_markdown_v2(text):\n",
        "    \"\"\"Helper function to escape special characters for MarkdownV2.\"\"\"\n",
        "    escape_chars = r'\\_*[]()~>#+-=|{}.!'\n",
        "    return ''.join(f'\\\\{char}' if char in escape_chars else char for char in text)\n",
        "\n",
        "\n",
        "\n",
        "# File to store user data\n",
        "USER_DATA_FILE = \"/content/drive/My Drive/telegram/user_data.json\"\n",
        "\n",
        "# Load existing user data from the file\n",
        "def load_user_data():\n",
        "    if os.path.exists(USER_DATA_FILE):\n",
        "        try:\n",
        "            with open(USER_DATA_FILE, 'r') as file:\n",
        "                data = file.read().strip()  # Read and strip whitespace\n",
        "                if data:  # Check if the file is not empty\n",
        "                    return json.loads(data)  # Parse JSON\n",
        "                else:\n",
        "                    print(\"User data file is empty. Starting with empty data.\")\n",
        "                    return {}\n",
        "        except json.JSONDecodeError:\n",
        "            print(\"Invalid JSON in file. Starting with empty data.\")\n",
        "            return {}\n",
        "    print(\"No existing file found in Google Drive. Starting with empty data.\")\n",
        "    return {}\n",
        "\n",
        "# Save user data to the file\n",
        "def save_user_data():\n",
        "    try:\n",
        "        with open(USER_DATA_FILE, 'w') as file:\n",
        "            print(f\"Saving user data to {USER_DATA_FILE}...\")\n",
        "            json.dump(user_wallets, file)\n",
        "            print(\"Data saved successfully.\")\n",
        "    except Exception as e:\n",
        "        print(f\"Failed to save data: {str(e)}\")\n",
        "\n",
        "# Initialize the user data\n",
        "user_wallets = load_user_data()\n",
        "\n",
        "for user_id in user_wallets:\n",
        "    if 'swap_presets' not in user_wallets[user_id]:\n",
        "        user_wallets[user_id]['swap_presets'] = [10, 20, 30, 40, 50]  # Default values\n",
        "\n",
        "user_positions = {user_id: data.get('positions', []) for user_id, data in user_wallets.items()}\n",
        "# Ensure user_positions is initialized properly\n",
        "\n",
        "\n",
        "def escape_markdown_v2(text):\n",
        "    \"\"\"Helper function to escape special characters for MarkdownV2.\"\"\"\n",
        "    escape_chars = r'\\_*[]()~>#+-=|{}.!'  # Add '.' to the list of escape characters\n",
        "    return ''.join(f'\\\\{char}' if char in escape_chars else char for char in text)\n",
        "\n",
        "def create_new_wallet(user_id):\n",
        "    account = Account.create()\n",
        "    address, private_key = account.address, account.key.hex()\n",
        "    user_wallets[user_id] = {'address': address, 'private_key': private_key, 'positions': []}\n",
        "    save_user_data()  # Save data after creating a new wallet\n",
        "    return address, private_key\n",
        "\n",
        "def get_matic_balance(wallet_address):\n",
        "    balance = web3.eth.get_balance(wallet_address)\n",
        "    return balance / (10 ** 18)\n",
        "\n",
        "def get_token_info(contract_address):\n",
        "    # Example API call to get token info (using DexScreener as an example)\n",
        "    url = f\"https://api.dexscreener.io/latest/dex/tokens/{contract_address}\"\n",
        "\n",
        "    try:\n",
        "        response = requests.get(url)\n",
        "        response.raise_for_status()  # Raise an exception for HTTP errors\n",
        "        data = response.json()\n",
        "\n",
        "        # Check if 'pairs' exists and is a list with at least one element\n",
        "        if 'pairs' in data and isinstance(data['pairs'], list) and len(data['pairs']) > 0:\n",
        "            token_info = data['pairs'][0]\n",
        "            name = token_info['baseToken']['name']\n",
        "            ticker = token_info['baseToken']['symbol']\n",
        "            fdv = token_info.get('fdv', 0)  # Fully Diluted Valuation\n",
        "            price = token_info['priceUsd']\n",
        "            liquidity = token_info['liquidity']['usd']\n",
        "            dex = token_info['dexId']\n",
        "\n",
        "            # Format the FDV and liquidity\n",
        "            formatted_fdv = f\"{fdv:,.2f}\" if fdv else \"N/A\"\n",
        "            formatted_liquidity = f\"{liquidity:,.2f}\" if liquidity else \"N/A\"\n",
        "\n",
        "            return {\n",
        "                \"name\": name,\n",
        "                \"ticker\": ticker,\n",
        "                \"fdv\": formatted_fdv,\n",
        "                \"price\": price,\n",
        "                \"liquidity\": formatted_liquidity,\n",
        "                \"dex\": dex\n",
        "            }\n",
        "        else:\n",
        "            # Log and return None if 'pairs' is not found or is empty\n",
        "            print(f\"No valid token data found for contract address {contract_address}\")\n",
        "            return None\n",
        "\n",
        "    except requests.exceptions.HTTPError as http_err:\n",
        "        print(f\"HTTP error occurred: {http_err}\")\n",
        "    except requests.exceptions.RequestException as err:\n",
        "        print(f\"Error occurred: {err}\")\n",
        "    except KeyError:\n",
        "        print(\"Invalid response structure. Check the contract address or API response.\")\n",
        "\n",
        "    return None\n",
        "\n",
        "\n",
        "\n",
        "def get_token_balance(wallet_address, token_address):\n",
        "    token_contract = web3.eth.contract(address=token_address, abi=[\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}],\n",
        "            \"name\": \"balanceOf\",\n",
        "            \"outputs\": [{\"name\": \"balance\", \"type\": \"uint256\"}],\n",
        "            \"type\": \"function\"\n",
        "        },\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [],\n",
        "            \"name\": \"decimals\",\n",
        "            \"outputs\": [{\"name\": \"\", \"type\": \"uint8\"}],\n",
        "            \"type\": \"function\"\n",
        "        }\n",
        "    ])\n",
        "    balance = token_contract.functions.balanceOf(wallet_address).call()\n",
        "    decimals = token_contract.functions.decimals().call()\n",
        "    return balance / (10 ** decimals)\n",
        "\n",
        "def add_or_update_position(user_id, token_address, matic_amount, is_sell=False):\n",
        "    \"\"\"\n",
        "    Adds or updates a position. If the balance is zero, the position is removed.\n",
        "    If is_sell is True, it subtracts the amount instead of adding.\n",
        "    \"\"\"\n",
        "    # Check if the token already exists in user's positions\n",
        "    existing_position = None\n",
        "    for position in user_wallets[user_id]['positions']:\n",
        "        if position['token_address'] == token_address:\n",
        "            existing_position = position\n",
        "            break\n",
        "\n",
        "    # Get the user's updated token balance\n",
        "    wallet_address = user_wallets[user_id]['address']\n",
        "    token_balance = get_token_balance(wallet_address, token_address)\n",
        "\n",
        "    print(f\"Token balance for {token_address}: {token_balance}\")  # Debugging statement\n",
        "\n",
        "    if existing_position:\n",
        "        if is_sell:\n",
        "            # Optional: Track cost based on sell (depends on how you manage costs)\n",
        "            existing_position['cost_in_matic'] -= matic_amount\n",
        "\n",
        "        # If the balance is zero, remove the position\n",
        "        if token_balance == 0:\n",
        "            print(f\"Removing position for {token_address} due to zero balance.\")  # Debugging statement\n",
        "            user_wallets[user_id]['positions'].remove(existing_position)\n",
        "        else:\n",
        "            # Update the cost in MATIC for the existing position\n",
        "            print(f\"Updating position for {token_address} with new balance: {token_balance}\")  # Debugging statement\n",
        "            existing_position['cost_in_matic'] = max(existing_position['cost_in_matic'], 0)\n",
        "    else:\n",
        "        if token_balance > 0:\n",
        "            # Add a new position if the balance is greater than zero\n",
        "            print(f\"Adding new position for {token_address}.\")  # Debugging statement\n",
        "            user_wallets[user_id]['positions'].append({\n",
        "                'token_address': token_address,\n",
        "                'cost_in_matic': matic_amount  # Store the actual MATIC spent\n",
        "            })\n",
        "\n",
        "    # Save updated user data\n",
        "    save_user_data()\n",
        "\n",
        "# Modify the swap_matic_for_tokens function\n",
        "def swap_matic_for_tokens(user_id, token_address, matic_amount):\n",
        "    wallet_info = user_wallets[user_id]\n",
        "    wallet_address = wallet_info['address']\n",
        "    private_key = wallet_info['private_key']\n",
        "\n",
        "    # Get the user's buy slippage setting (default to 1%)\n",
        "    buy_slippage = user_wallets.get(user_id, {}).get('buy_slippage', 1)\n",
        "\n",
        "    # Set the deadline for the transaction (10 minutes from now)\n",
        "    deadline = int(time.time()) + 600\n",
        "\n",
        "    # Calculate the minimum amount out, adjusted for slippage\n",
        "    try:\n",
        "        # Get the estimated amount of tokens for the provided MATIC amount\n",
        "        amounts_out = router_contract.functions.getAmountsOut(\n",
        "            web3.to_wei(matic_amount, 'ether'),\n",
        "            [wmatic_address, token_address]\n",
        "        ).call()\n",
        "\n",
        "        # The last element of amounts_out is the amount of the desired token (amountOut)\n",
        "        amount_out_min = amounts_out[-1] * (1 - (buy_slippage / 100))  # Adjust for slippage\n",
        "\n",
        "    except Exception as e:\n",
        "        return f\"Error getting token amounts: {str(e)}\"\n",
        "\n",
        "    # Get the nonce for the wallet\n",
        "    nonce = web3.eth.get_transaction_count(wallet_address)\n",
        "\n",
        "    # Use dynamic gas estimation\n",
        "    try:\n",
        "        gas_estimate = router_contract.functions.swapExactETHForTokens(\n",
        "            int(amount_out_min),  # Minimal amount out based on slippage\n",
        "            [wmatic_address, token_address],  # Path from MATIC to desired token\n",
        "            wallet_address,\n",
        "            deadline\n",
        "        ).estimate_gas({\n",
        "            'from': wallet_address,\n",
        "            'value': web3.to_wei(matic_amount, 'ether'),\n",
        "            'gasPrice': web3.eth.gas_price,\n",
        "            'nonce': nonce\n",
        "        })\n",
        "    except Exception as e:\n",
        "        return f\"Gas estimation failed: {str(e)}\"\n",
        "\n",
        "    # Build the transaction\n",
        "    transaction = router_contract.functions.swapExactETHForTokens(\n",
        "        int(amount_out_min),  # Minimal amount out\n",
        "        [wmatic_address, token_address],  # Path from MATIC to desired token\n",
        "        wallet_address,\n",
        "        deadline\n",
        "    ).build_transaction({\n",
        "        'from': wallet_address,\n",
        "        'value': web3.to_wei(matic_amount, 'ether'),\n",
        "        'gas': gas_estimate,\n",
        "        'gasPrice': web3.eth.gas_price,\n",
        "        'nonce': nonce,\n",
        "        'chainId': 137  # Polygon Mainnet\n",
        "    })\n",
        "\n",
        "    # Ensure wallet has enough MATIC for both the swap and gas fees\n",
        "    wallet_balance = web3.eth.get_balance(wallet_address)\n",
        "    total_cost = web3.to_wei(matic_amount, 'ether') + gas_estimate * web3.eth.gas_price\n",
        "\n",
        "    if wallet_balance < total_cost:\n",
        "        return \"Insufficient MATIC balance for the swap and gas fees.\"\n",
        "\n",
        "    # Sign and send the transaction\n",
        "    try:\n",
        "        signed_txn = web3.eth.account.sign_transaction(transaction, private_key=private_key)\n",
        "        txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)\n",
        "    except Exception as e:\n",
        "        return f\"Transaction submission failed: {str(e)}\"\n",
        "\n",
        "    # Wait for the transaction receipt\n",
        "    try:\n",
        "        receipt = web3.eth.wait_for_transaction_receipt(txn_hash, timeout=300)\n",
        "        if receipt['status'] == 1:\n",
        "            # After a successful swap, add or update the token position\n",
        "            add_or_update_position(user_id, token_address, matic_amount)\n",
        "            return web3.to_hex(txn_hash)\n",
        "        else:\n",
        "            return f\"Transaction failed with status: {receipt['status']}\"\n",
        "    except Exception as e:\n",
        "        return f\"Transaction submitted but receipt could not be confirmed: {str(e)}\"\n",
        "\n",
        "# Modify the swap_tokens_for_matic function to remove positions when balance reaches zero\n",
        "def swap_tokens_for_matic(user_id, token_address):\n",
        "    wallet_info = user_wallets[user_id]\n",
        "    wallet_address = wallet_info['address']\n",
        "    private_key = wallet_info['private_key']\n",
        "\n",
        "    # Get the token contract\n",
        "    token_contract = web3.eth.contract(address=token_address, abi=[\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}],\n",
        "            \"name\": \"balanceOf\",\n",
        "            \"outputs\": [{\"name\": \"balance\", \"type\": \"uint256\"}],\n",
        "            \"type\": \"function\"\n",
        "        },\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [],\n",
        "            \"name\": \"decimals\",\n",
        "            \"outputs\": [{\"name\": \"\", \"type\": \"uint8\"}],\n",
        "            \"type\": \"function\"\n",
        "        },\n",
        "        {\n",
        "            \"constant\": False,\n",
        "            \"inputs\": [{\"name\": \"_spender\", \"type\": \"address\"}, {\"name\": \"_value\", \"type\": \"uint256\"}],\n",
        "            \"name\": \"approve\",\n",
        "            \"outputs\": [{\"name\": \"success\", \"type\": \"bool\"}],\n",
        "            \"type\": \"function\"\n",
        "        }\n",
        "    ])\n",
        "\n",
        "     # Get the user's token balance and decimals\n",
        "    token_balance = token_contract.functions.balanceOf(wallet_address).call()\n",
        "    decimals = token_contract.functions.decimals().call()\n",
        "    token_balance_in_wei = int(token_balance * (10 ** decimals))  # Convert balance to wei\n",
        "\n",
        "    # Set the deadline for the swap (10 minutes from now)\n",
        "    deadline = int(time.time()) + 600\n",
        "\n",
        "    # Step 1: Approve the router to spend the tokens\n",
        "    try:\n",
        "        approve_txn = token_contract.functions.approve(\n",
        "            router_contract_address,\n",
        "            token_balance_in_wei\n",
        "        ).build_transaction({\n",
        "            'from': wallet_address,\n",
        "            'gas': 100000,  # Fixed gas limit for approval\n",
        "            'gasPrice': web3.to_wei('90', 'gwei'),  # Fixed gas price\n",
        "            'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "            'chainId': 137  # Polygon mainnet chain ID\n",
        "        })\n",
        "\n",
        "        # Sign and send the approval transaction\n",
        "        signed_approve_txn = web3.eth.account.sign_transaction(approve_txn, private_key)\n",
        "        approve_txn_hash = web3.eth.send_raw_transaction(signed_approve_txn.raw_transaction)\n",
        "        web3.eth.wait_for_transaction_receipt(approve_txn_hash)\n",
        "        print(f\"Approval successful, transaction hash: {web3.to_hex(approve_txn_hash)}\")\n",
        "\n",
        "    except Exception as e:\n",
        "        return f\"Approval failed: {str(e)}\"\n",
        "\n",
        "    # Step 2: Perform the swap to sell the tokens for MATIC\n",
        "    try:\n",
        "        sell_txn = router_contract.functions.swapExactTokensForETH(\n",
        "            token_balance_in_wei,  # Amount of tokens to sell\n",
        "            0,  # Accept any amount of MATIC (no minimum)\n",
        "            [token_address, wmatic_address],  # Path: Token -> MATIC\n",
        "            wallet_address,  # Recipient address\n",
        "            deadline  # Deadline\n",
        "        ).build_transaction({\n",
        "            'from': wallet_address,\n",
        "            'gas': 200000,  # Fixed gas limit for the swap\n",
        "            'gasPrice': web3.to_wei('90', 'gwei'),  # Fixed gas price\n",
        "            'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "            'chainId': 137  # Polygon mainnet chain ID\n",
        "        })\n",
        "\n",
        "        # Sign and send the sell transaction\n",
        "        signed_sell_txn = web3.eth.account.sign_transaction(sell_txn, private_key)\n",
        "        sell_txn_hash = web3.eth.send_raw_transaction(signed_sell_txn.raw_transaction)\n",
        "        sell_receipt = web3.eth.wait_for_transaction_receipt(sell_txn_hash)\n",
        "\n",
        "        print(f\"Sell successful, transaction hash: {web3.to_hex(sell_txn_hash)}\")\n",
        "\n",
        "        # Step 3: Handle 1% tax on the MATIC received\n",
        "        if sell_receipt['status'] == 1:\n",
        "            # Fetch the MATIC received from the sell transaction\n",
        "            logs = sell_receipt['logs']\n",
        "            matic_received = 0\n",
        "\n",
        "            for log in logs:\n",
        "                # Check if this log corresponds to receiving MATIC (WETH equivalent on Polygon)\n",
        "                if 'topics' in log and wmatic_address in log['address']:\n",
        "                    matic_received += int(log['data'], 16)  # Log data contains MATIC amount in wei\n",
        "\n",
        "            if matic_received > 0:\n",
        "                # Calculate the 1% tax\n",
        "                tax_amount = matic_received * 0.01\n",
        "                remaining_matic = matic_received - tax_amount\n",
        "\n",
        "                # Send the 1% tax to the tax wallet\n",
        "                tax_txn = {\n",
        "                    'from': wallet_address,\n",
        "                    'to': tax_wallet_address,\n",
        "                    'value': tax_amount,\n",
        "                    'gas': 21000,\n",
        "                    'gasPrice': web3.eth.gas_price,\n",
        "                    'nonce': web3.eth.get_transaction_count(wallet_address) + 1,  # New nonce\n",
        "                    'chainId': 137  # Polygon Mainnet\n",
        "                }\n",
        "\n",
        "                signed_tax_txn = web3.eth.account.sign_transaction(tax_txn, private_key)\n",
        "                tax_txn_hash = web3.eth.send_raw_transaction(signed_tax_txn.raw_transaction)\n",
        "                web3.eth.wait_for_transaction_receipt(tax_txn_hash)\n",
        "                print(f\"Tax sent successfully: {tax_txn_hash.hex()}\")\n",
        "\n",
        "                return f\"Sell successful with 1% tax! Transaction Hash: {sell_txn_hash.hex()} | Tax Hash: {tax_txn_hash.hex()}\"\n",
        "\n",
        "    except Exception as e:\n",
        "        return f\"Swap transaction failed: {str(e)}\"\n",
        "\n",
        "def sell_token(user_id, token_address):\n",
        "    wallet_info = user_wallets[user_id]\n",
        "    wallet_address = wallet_info['address']\n",
        "    private_key = wallet_info['private_key']\n",
        "\n",
        "    # Get the token contract\n",
        "    token_contract = web3.eth.contract(address=token_address, abi=[\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}],\n",
        "            \"name\": \"balanceOf\",\n",
        "            \"outputs\": [{\"name\": \"balance\", \"type\": \"uint256\"}],\n",
        "            \"type\": \"function\"\n",
        "        },\n",
        "        {\n",
        "            \"constant\": False,\n",
        "            \"inputs\": [{\"name\": \"_spender\", \"type\": \"address\"}, {\"name\": \"_value\", \"type\": \"uint256\"}],\n",
        "            \"name\": \"approve\",\n",
        "            \"outputs\": [{\"name\": \"success\", \"type\": \"bool\"}],\n",
        "            \"type\": \"function\"\n",
        "        },\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}, {\"name\": \"_spender\", \"type\": \"address\"}],\n",
        "            \"name\": \"allowance\",\n",
        "            \"outputs\": [{\"name\": \"remaining\", \"type\": \"uint256\"}],\n",
        "            \"type\": \"function\"\n",
        "        }\n",
        "    ])\n",
        "\n",
        "    # Fetch the token balance directly in the smallest unit (already in smallest unit)\n",
        "    token_balance_in_wei = token_contract.functions.balanceOf(wallet_address).call()\n",
        "\n",
        "    if token_balance_in_wei == 0:\n",
        "        return \"Insufficient token balance to sell.\"\n",
        "\n",
        "    print(f\"Token balance: {token_balance_in_wei}\")\n",
        "\n",
        "    # Get the user's custom sell slippage (default to 1%)\n",
        "    sell_slippage = user_wallets.get(user_id, {}).get('sell_slippage', 1)\n",
        "\n",
        "    # Deadline for the transaction (10 minutes from now)\n",
        "    deadline = int(time.time()) + 600\n",
        "\n",
        "    # Step 1: Check allowance and approve if necessary\n",
        "    allowance = token_contract.functions.allowance(wallet_address, router_contract_address).call()\n",
        "    if allowance < token_balance_in_wei:\n",
        "        print(f\"Current allowance: {allowance}. Approving router to spend {token_balance_in_wei} tokens.\")\n",
        "\n",
        "        # Approve the router to spend the tokens\n",
        "        approve_txn = token_contract.functions.approve(\n",
        "            router_contract_address,\n",
        "            token_balance_in_wei\n",
        "        ).build_transaction({\n",
        "            'from': wallet_address,\n",
        "            'gas': 100000,\n",
        "            'gasPrice': web3.to_wei('90', 'gwei'),\n",
        "            'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "            'chainId': 137  # Polygon mainnet\n",
        "        })\n",
        "\n",
        "        signed_approve_txn = web3.eth.account.sign_transaction(approve_txn, private_key)\n",
        "        approve_txn_hash = web3.eth.send_raw_transaction(signed_approve_txn.raw_transaction)\n",
        "\n",
        "        # Wait for the approval transaction to be confirmed\n",
        "        approve_receipt = web3.eth.wait_for_transaction_receipt(approve_txn_hash)\n",
        "        print(f\"Approval transaction hash: {web3.to_hex(approve_txn_hash)}\")\n",
        "\n",
        "        if approve_receipt.status != 1:\n",
        "            return \"Approval transaction failed.\"\n",
        "\n",
        "    # Step 2: Get minimum amount of MATIC after applying slippage\n",
        "    try:\n",
        "        # Get the expected amount of MATIC from the swap\n",
        "        amounts_out = router_contract.functions.getAmountsOut(\n",
        "            token_balance_in_wei,\n",
        "            [token_address, wmatic_address]\n",
        "        ).call()\n",
        "\n",
        "        # The last element of amounts_out is the MATIC amount expected from the swap\n",
        "        amount_out_min = amounts_out[-1] * (1 - (sell_slippage / 100))  # Adjust for slippage\n",
        "\n",
        "    except Exception as e:\n",
        "        return f\"Error calculating token amounts: {str(e)}\"\n",
        "\n",
        "    # Step 3: Perform the swap to sell the tokens for MATIC\n",
        "    try:\n",
        "        print(\"Proceeding with token swap...\")\n",
        "\n",
        "        sell_txn = router_contract.functions.swapExactTokensForETH(\n",
        "            token_balance_in_wei,  # Use the full token balance in smallest unit\n",
        "            int(amount_out_min),  # Minimum amount of MATIC to accept after slippage\n",
        "            [token_address, wmatic_address],  # Path: Token -> MATIC\n",
        "            wallet_address,  # Recipient address\n",
        "            deadline  # Deadline\n",
        "        ).build_transaction({\n",
        "            'from': wallet_address,\n",
        "            'gas': 200000,\n",
        "            'gasPrice': web3.to_wei('90', 'gwei'),\n",
        "            'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "            'chainId': 137  # Polygon mainnet chain ID\n",
        "        })\n",
        "\n",
        "        # Sign and send the sell transaction\n",
        "        signed_sell_txn = web3.eth.account.sign_transaction(sell_txn, private_key)\n",
        "        sell_txn_hash = web3.eth.send_raw_transaction(signed_sell_txn.raw_transaction)\n",
        "\n",
        "        # Wait for transaction receipt\n",
        "        sell_receipt = web3.eth.wait_for_transaction_receipt(sell_txn_hash)\n",
        "        print(f\"Sell successful, transaction hash: {sell_txn_hash.hex()}\")\n",
        "\n",
        "        return sell_receipt\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Error during swap: {str(e)}\")\n",
        "        return f\"Error during swap: {str(e)}\"\n",
        "\n",
        "def sell_percent(user_id, token_address, percent):\n",
        "    wallet_info = user_wallets[user_id]\n",
        "    wallet_address = wallet_info['address']\n",
        "    private_key = wallet_info['private_key']\n",
        "\n",
        "    # Get the token contract\n",
        "    token_contract = web3.eth.contract(address=token_address, abi=[\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}],\n",
        "            \"name\": \"balanceOf\",\n",
        "            \"outputs\": [{\"name\": \"balance\", \"type\": \"uint256\"}],\n",
        "            \"type\": \"function\"\n",
        "        },\n",
        "        {\n",
        "            \"constant\": False,\n",
        "            \"inputs\": [{\"name\": \"_spender\", \"type\": \"address\"}, {\"name\": \"_value\", \"type\": \"uint256\"}],\n",
        "            \"name\": \"approve\",\n",
        "            \"outputs\": [{\"name\": \"success\", \"type\": \"bool\"}],\n",
        "            \"type\": \"function\"\n",
        "        },\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}, {\"name\": \"_spender\", \"type\": \"address\"}],\n",
        "            \"name\": \"allowance\",\n",
        "            \"outputs\": [{\"name\": \"remaining\", \"type\": \"uint256\"}],\n",
        "            \"type\": \"function\"\n",
        "        }\n",
        "    ])\n",
        "\n",
        "    # Fetch the token balance directly in the smallest unit (already in smallest unit)\n",
        "    token_balance_in_wei = token_contract.functions.balanceOf(wallet_address).call()\n",
        "    if token_balance_in_wei == 0:\n",
        "        return \"Insufficient token balance to sell.\"\n",
        "\n",
        "    # Calculate the amount to sell based on the percentage\n",
        "    amount_to_sell = int(token_balance_in_wei * (percent / 100))\n",
        "\n",
        "    print(f\"Total token balance: {token_balance_in_wei} | Selling {percent}% = {amount_to_sell}\")\n",
        "\n",
        "    # Deadline for the transaction (10 minutes from now)\n",
        "    deadline = int(time.time()) + 600\n",
        "\n",
        "    # Step 1: Check allowance and approve if necessary\n",
        "    allowance = token_contract.functions.allowance(wallet_address, router_contract_address).call()\n",
        "    if allowance < amount_to_sell:\n",
        "        print(f\"Current allowance: {allowance}. Approving router to spend {amount_to_sell} tokens.\")\n",
        "\n",
        "        # Approve the router to spend the tokens\n",
        "        approve_txn = token_contract.functions.approve(\n",
        "            router_contract_address,\n",
        "            amount_to_sell\n",
        "        ).build_transaction({\n",
        "            'from': wallet_address,\n",
        "            'gas': 100000,\n",
        "            'gasPrice': int(web3.eth.gas_price * 1.2),  # Convert gasPrice to an integer\n",
        "            'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "            'chainId': 137  # Polygon mainnet\n",
        "        })\n",
        "\n",
        "        signed_approve_txn = web3.eth.account.sign_transaction(approve_txn, private_key)\n",
        "        approve_txn_hash = web3.eth.send_raw_transaction(signed_approve_txn.raw_transaction)\n",
        "\n",
        "        # Wait for the approval transaction to be confirmed\n",
        "        approve_receipt = web3.eth.wait_for_transaction_receipt(approve_txn_hash)\n",
        "        print(f\"Approval transaction hash: {web3.to_hex(approve_txn_hash)}\")\n",
        "\n",
        "        if approve_receipt.status != 1:\n",
        "            return \"Approval transaction failed.\"\n",
        "\n",
        "    # Step 2: Perform the swap to sell the tokens for MATIC\n",
        "    try:\n",
        "        print(f\"Proceeding with token swap... Selling {amount_to_sell} tokens\")\n",
        "\n",
        "        sell_txn = router_contract.functions.swapExactTokensForETH(\n",
        "            amount_to_sell,  # Amount of tokens to sell\n",
        "            0,  # Accept any amount of MATIC (you can set a minimum to avoid slippage)\n",
        "            [token_address, wmatic_address],  # Path: Token -> MATIC\n",
        "            wallet_address,  # Recipient address\n",
        "            deadline  # Deadline\n",
        "        ).build_transaction({\n",
        "            'from': wallet_address,\n",
        "            'gas': 200000,\n",
        "            'gasPrice': int(web3.eth.gas_price * 1.2),  # Convert gasPrice to an integer\n",
        "            'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "            'chainId': 137  # Polygon mainnet chain ID\n",
        "        })\n",
        "\n",
        "        # Sign and send the sell transaction\n",
        "        signed_sell_txn = web3.eth.account.sign_transaction(sell_txn, private_key)\n",
        "        sell_txn_hash = web3.eth.send_raw_transaction(signed_sell_txn.raw_transaction)\n",
        "\n",
        "        # Wait for transaction receipt\n",
        "        sell_receipt = web3.eth.wait_for_transaction_receipt(sell_txn_hash)\n",
        "        print(f\"Sell successful, transaction hash: {sell_txn_hash.hex()}\")\n",
        "\n",
        "        return sell_receipt\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Error during swap: {str(e)}\")\n",
        "        return f\"Error during swap: {str(e)}\"\n",
        "\n",
        "\n",
        "def show_wallet_info(user_id, chat_id):\n",
        "    # Ensure the user has a wallet\n",
        "    if user_id not in user_wallets:\n",
        "        bot.send_message(chat_id, \"You don't have a wallet yet. Please type /start to create one.\")\n",
        "        return\n",
        "\n",
        "    wallet_info = user_wallets[user_id]\n",
        "    wallet_address = wallet_info['address']\n",
        "    matic_balance = get_matic_balance(wallet_address)\n",
        "\n",
        "    print(f\"Showing wallet info for user_id: {user_id}\")  # Debugging\n",
        "    print(f\"Wallet Address: {wallet_address}, MATIC Balance: {matic_balance}\")  # Debugging\n",
        "\n",
        "    # Format the wallet address and balance without MarkdownV2\n",
        "    wallet_message = (\n",
        "        f\"🏦 Wallet Address: {wallet_address}\\n\\n\"\n",
        "        f\"💰 POL Balance: {matic_balance:.6f} POL\"\n",
        "    )\n",
        "\n",
        "    # Create inline button with dynamic Polygonscan link\n",
        "    markup = InlineKeyboardMarkup()\n",
        "    view_on_polygonscan_button = InlineKeyboardButton(\"🔍 Polygonscan\", url=f\"https://polygonscan.com/address/{wallet_address}\")\n",
        "    refresh_button = InlineKeyboardButton(\"🔄 Refresh\", callback_data=\"refresh_wallet_info\")\n",
        "    deposit_button = InlineKeyboardButton(\"➕ Deposit POL\", callback_data=\"deposit_pol\")\n",
        "    withdraw_x_button = InlineKeyboardButton(\"Withdraw X POL\", callback_data=\"withdraw_x_pol\")\n",
        "    withdraw_all_button = InlineKeyboardButton(\"Withdraw All POL\", callback_data=\"withdraw_all_pol\")\n",
        "    export_key_button = InlineKeyboardButton(\"🔑 Export Private Key\", callback_data=\"export_private_key\")\n",
        "    back_button = InlineKeyboardButton(\"🔙 Back\", callback_data=\"back_to_start\")\n",
        "\n",
        "    # Add buttons to the markup\n",
        "    markup.add(view_on_polygonscan_button, refresh_button)\n",
        "    markup.add(deposit_button)\n",
        "    markup.add(withdraw_x_button, withdraw_all_button)\n",
        "    markup.add(export_key_button)\n",
        "    markup.add(back_button)  # Add the \"Back\" button\n",
        "    # Send the plain text message without MarkdownV2\n",
        "    bot.send_message(chat_id, wallet_message, reply_markup=markup)\n",
        "\n",
        "@bot.callback_query_handler(func=lambda call: call.data == \"refresh_wallet_info\")\n",
        "def handle_refresh(call):\n",
        "    user_id = str(call.message.chat.id)\n",
        "    chat_id = call.message.chat.id\n",
        "\n",
        "    # Delete the previous message\n",
        "    bot.delete_message(chat_id, call.message.message_id)\n",
        "\n",
        "    # Refresh wallet information\n",
        "    show_wallet_info(user_id, chat_id)\n",
        "\n",
        "@bot.message_handler(commands=['settings'])\n",
        "def handle_settings_command(message):\n",
        "    user_id = str(message.chat.id)\n",
        "\n",
        "    # Call the function to display the settings menu\n",
        "    show_settings_menu(user_id, message.chat.id)\n",
        "\n",
        "def show_settings_menu(user_id, chat_id):\n",
        "    markup = InlineKeyboardMarkup()\n",
        "\n",
        "    # Settings buttons\n",
        "    presets_button = InlineKeyboardButton(\"📝 Configure Swap Presets\", callback_data=\"configure_swap_presets\")\n",
        "    slippage_button = InlineKeyboardButton(\"⚖️ Slippage Settings\", callback_data=\"slippage_settings\")\n",
        "    back_button = InlineKeyboardButton(\"🔙 Back\", callback_data=\"back_to_start\")\n",
        "\n",
        "    # Add buttons to the markup\n",
        "    markup.add(presets_button)\n",
        "    markup.add(slippage_button)\n",
        "    markup.add(back_button)\n",
        "\n",
        "    # Send the settings message\n",
        "    bot.send_message(chat_id, \"⚙️ *Settings Menu*\\n\\nChoose an option to configure your preferences:\", reply_markup=markup, parse_mode=\"Markdown\")\n",
        "\n",
        "@bot.callback_query_handler(func=lambda call: call.data == \"settings\")\n",
        "def handle_settings(call):\n",
        "    user_id = str(call.message.chat.id)\n",
        "    bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the previous message\n",
        "    show_settings_menu(user_id, call.message.chat.id)\n",
        "\n",
        "\n",
        "#----------------------------------------------------------------------------------------------------------------------\n",
        "\n",
        "\n",
        "\n",
        "@bot.message_handler(commands=['start'])\n",
        "def send_welcome(message):\n",
        "    user_id = str(message.chat.id)  # Telegram user ID as string\n",
        "    if user_id not in user_wallets:\n",
        "        address, private_key = create_new_wallet(user_id)\n",
        "        bot.send_message(message.chat.id, \"A new wallet has been created for you.\")\n",
        "    else:\n",
        "        bot.send_message(message.chat.id, \"Welcome back! Your wallet is ready to use.\")\n",
        "\n",
        "    # Create inline buttons\n",
        "    markup = InlineKeyboardMarkup()\n",
        "    buy_button = InlineKeyboardButton(\"🛒 Buy\", callback_data=\"buy\")\n",
        "    positions_button = InlineKeyboardButton(\"📊 Positions\", callback_data=\"positions\")\n",
        "    wallet_button = InlineKeyboardButton(\"💼 Wallet\", callback_data=\"wallet\")\n",
        "    pat_button = InlineKeyboardButton(\"🟣 PAT\", url=\"https://t.me/patonpolygon\")\n",
        "    settings_button = InlineKeyboardButton(\"⚙️ Settings\", callback_data=\"settings\")\n",
        "    coming_soon_button = InlineKeyboardButton(\"---- Coming Soon ----\", callback_data=\"coming_soon\")\n",
        "    bridge_button = InlineKeyboardButton(\"🌉 Bridge\", callback_data=\"bridge\")\n",
        "    refer_button = InlineKeyboardButton(\"👥 Refer Friends\", callback_data=\"refer\")\n",
        "    backup_button = InlineKeyboardButton(\"🤖  Backup\", callback_data=\"backup\")\n",
        "\n",
        "    # Add buttons to the markup\n",
        "    markup.add(buy_button, positions_button, pat_button)\n",
        "    markup.add(settings_button, wallet_button)\n",
        "    markup.add(coming_soon_button)\n",
        "    markup.add(bridge_button, refer_button, backup_button)\n",
        "\n",
        "    bot.send_message(message.chat.id, \"*PAT Bot (Beta)* 🟣\\n\\nThe first QuickSwap Trading Bot on Telegram\\n\\n*Choose an option below to get started*\", reply_markup=markup, parse_mode=\"Markdown\")\n",
        "\n",
        "@bot.callback_query_handler(func=lambda call: True)\n",
        "def handle_query(call):\n",
        "    user_id = str(call.message.chat.id)\n",
        "\n",
        "    if user_id not in user_wallets:\n",
        "        bot.send_message(call.message.chat.id, \"You don't have a wallet yet. Please type /start to create one.\")\n",
        "        return\n",
        "\n",
        "     # Handle the \"Cancel\" button press\n",
        "    if call.data == \"cancel\":\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the current message\n",
        "        send_welcome(call.message)  # Bring the user back to the welcome screen\n",
        "\n",
        "    if call.data.startswith(\"selling_menu_\"):\n",
        "        token_address = call.data.split(\"_\")[2]\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the previous message to prevent duplicate menus\n",
        "        display_selling_menu(user_id, token_address)  # Display the sell menu\n",
        "    elif call.data == \"wallet\":\n",
        "        show_wallet_info(user_id, call.message.chat.id)\n",
        "    elif call.data == \"buy\":\n",
        "        msg = bot.send_message(call.message.chat.id, \"Please enter the contract address (CA) of the token you want to buy:\")\n",
        "        bot.register_next_step_handler(msg, prompt_matic_amount)\n",
        "    elif call.data == \"positions\":\n",
        "        show_positions(call.message)\n",
        "\n",
        "\n",
        "    if call.data.startswith(\"swap_\"):\n",
        "      parts = call.data.split(\"_\")\n",
        "      matic_amount = parts[1]  # This would be '1', '2', or 'X'\n",
        "      token_address = parts[2]  # The token address\n",
        "\n",
        "      if matic_amount == \"X\":\n",
        "          # If user chooses \"X\", ask them to input the MATIC amount\n",
        "          msg = bot.send_message(call.message.chat.id, \"Please enter the amount of MATIC you want to swap:\")\n",
        "          bot.register_next_step_handler(msg, ask_for_confirmation, token_address)\n",
        "      else:\n",
        "          try:\n",
        "              # Delete the previous message before proceeding\n",
        "              bot.delete_message(call.message.chat.id, call.message.message_id)\n",
        "\n",
        "              # Show \"Buy Pending\" message\n",
        "              bot.send_message(call.message.chat.id, \"Buy Pending 🟡\")\n",
        "\n",
        "              # Perform the swap\n",
        "              txn_hash = swap_matic_for_tokens(user_id, token_address, float(matic_amount))\n",
        "              bot.send_message(call.message.chat.id, f\"Buy successful 🟢 Transaction Hash: {txn_hash}\")\n",
        "              display_selling_menu(user_id, token_address)\n",
        "              # Transfer 1% tax to the tax wallet\n",
        "              tax_txn_hash = transfer_tax(user_id, token_address, float(matic_amount))\n",
        "\n",
        "              # Step 2: Approve token for sale (approval after tax)\n",
        "              approve_txn_hash = approve_token_for_sell(user_id, token_address)\n",
        "\n",
        "              # Display the sell menu after successful swap\n",
        "\n",
        "\n",
        "          except Exception as e:\n",
        "              bot.send_message(call.message.chat.id, f\"Swap failed: {str(e)}\")\n",
        "\n",
        "    elif call.data == \"confirm_swap\":\n",
        "      # Confirm the swap (This is the point where confirmation is happening)\n",
        "      user_id = str(call.message.chat.id)\n",
        "\n",
        "      # Send \"Buy Pending 🟡\" message right after confirmation\n",
        "\n",
        "      bot.send_message(call.message.chat.id, \"Buy Pending 🟡\")\n",
        "      # Proceed with the swap process\n",
        "      if 'pending_swap' in user_wallets[user_id]:\n",
        "          pending_swap = user_wallets[user_id]['pending_swap']\n",
        "          matic_amount = pending_swap['matic_amount']\n",
        "          token_address = pending_swap['token_address']\n",
        "\n",
        "          try:\n",
        "              txn_hash = swap_matic_for_tokens(user_id, token_address, matic_amount)\n",
        "              bot.delete_message(call.message.chat.id, call.message.message_id)\n",
        "              bot.send_message(call.message.chat.id, f\"Buy successful 🟢 Transaction Hash: {txn_hash}\")\n",
        "              # Transfer 1% tax to the tax wallet immediately after swap\n",
        "              tax_txn_hash = transfer_tax(user_id, token_address, matic_amount)\n",
        "              # After the swap is successful, display the sell menu for the token\n",
        "              display_selling_menu(user_id, token_address)\n",
        "\n",
        "          except Exception as e:\n",
        "              bot.send_message(call.message.chat.id, f\"Swap failed: {str(e)}\")\n",
        "      else:\n",
        "          bot.send_message(call.message.chat.id, \"No pending swap found.\")\n",
        "\n",
        "    elif call.data == \"cancel_swap\":\n",
        "        # Cancel the swap\n",
        "        bot.send_message(call.message.chat.id, \"Swap has been canceled.\")\n",
        "        send_welcome(call.message)  # Return to the main menu\n",
        "\n",
        "\n",
        "    if call.data.startswith(\"refresh_\"):\n",
        "        token_address = call.data.split(\"_\")[1]  # Extract token address from callback data\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the previous message\n",
        "        display_selling_menu(user_id, token_address)  # Refresh the token info\n",
        "    # Handle the \"Prev\" and \"Next\" button presses\n",
        "    if call.data.startswith(\"cycle_\"):\n",
        "        # Extract the direction (-1 for prev, 1 for next)\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)\n",
        "        direction = int(call.data.split(\"_\")[1])\n",
        "        cycle_position(call.message, user_id, direction)\n",
        "\n",
        "# Handle sell percentage dynamically\n",
        "    if call.data.startswith(\"sell_\"):\n",
        "      parts = call.data.split(\"_\")\n",
        "\n",
        "      # Ensure the callback data is correctly split into percentage and token address\n",
        "      if len(parts) == 3:\n",
        "        percentage_str = parts[1]  # Get the percentage (e.g., \"25\", \"50\", or \"X\")\n",
        "        token_address = parts[2]  # Get the token address\n",
        "\n",
        "        if percentage_str == \"X\":\n",
        "            # Ask the user to input the custom percentage\n",
        "            msg = bot.send_message(call.message.chat.id, \"Please enter the percentage you want to sell:\")\n",
        "\n",
        "            bot.register_next_step_handler(msg, process_custom_sell_percentage_with_tax, token_address)\n",
        "\n",
        "        elif percentage_str.isdigit():\n",
        "\n",
        "            try:\n",
        "                # Send a \"Sell Pending\" message\n",
        "                bot.send_message(call.message.chat.id, \"Sell Pending 🟡\")\n",
        "\n",
        "                # Clean up and verify the percentage string before converting to float\n",
        "                percentage = float(percentage_str.strip())\n",
        "\n",
        "                # Check if the percentage is valid\n",
        "                if percentage <= 0 or percentage > 100:\n",
        "                    bot.send_message(call.message.chat.id, \"Invalid percentage. Must be between 1 and 100.\")\n",
        "                    return\n",
        "\n",
        "                # Call the sell_percent function with the selected percentage\n",
        "                sell_receipt = sell_percent(user_id, token_address, percentage)\n",
        "\n",
        "                # Check if sell_receipt is a string (error message) or a transaction receipt (success)\n",
        "                if isinstance(sell_receipt, str):\n",
        "                    bot.send_message(call.message.chat.id, f\"Sell failed: {sell_receipt}\")\n",
        "                else:\n",
        "                    txn_hash = sell_receipt.transactionHash  # Extract the transaction hash from the receipt\n",
        "                    bot.send_message(call.message.chat.id, f\"Sell successful 🟢 Transaction Hash: {txn_hash.hex()}\")\n",
        "\n",
        "                    # Step 1: Calculate the amount of MATIC received from the sell\n",
        "                    matic_received = get_matic_received_from_txn(sell_receipt)  # Extract MATIC received\n",
        "\n",
        "                    if matic_received > 0:\n",
        "                        # Step 2: Calculate the 1% tax from the MATIC received\n",
        "                        tax_amount = matic_received * Decimal('0.5')\n",
        "\n",
        "                        # Step 3: Transfer the 1% tax to the tax wallet\n",
        "                        tax_txn_hash = transfer_tax(user_id, matic_received, tax_amount)\n",
        "\n",
        "                    else:\n",
        "                        bot.send_message(call.message.chat.id, \"No MATIC received from the sell transaction.\")\n",
        "\n",
        "                    # Step 4: Display the updated sell menu or return to the home menu\n",
        "                    display_selling_menu(user_id, token_address)\n",
        "\n",
        "            except ValueError as ve:\n",
        "                bot.send_message(call.message.chat.id, f\"Failed to parse token percentage. Error: {str(ve)}\")\n",
        "      else:\n",
        "          # If the callback data is not formatted as expected\n",
        "          bot.send_message(call.message.chat.id, \"Invalid callback data. Could not process sell request.\")\n",
        "\n",
        "\n",
        "    elif call.data.startswith(\"full_100_\"):\n",
        "        token_address = call.data.split(\"_\")[2]\n",
        "        bot.send_message(call.message.chat.id, \"Sell Pending 🟡\")\n",
        "        # Call the sell_token function to sell 100% of the tokens\n",
        "        sell_receipt = sell_token(user_id, token_address)\n",
        "\n",
        "        # Check if sell_receipt is a string (error) or a transaction receipt (successful)\n",
        "        if isinstance(sell_receipt, str):\n",
        "            # If it's a string, it's an error message\n",
        "            bot.send_message(call.message.chat.id, f\"Sell failed: {sell_receipt}\")\n",
        "        else:\n",
        "            # If it's a receipt, extract and display the transaction hash\n",
        "            txn_hash = sell_receipt.transactionHash  # Extract the transaction hash from the receipt\n",
        "            bot.send_message(call.message.chat.id, f\"Sell successful 🟢 Transaction Hash: {txn_hash.hex()}\")\n",
        "\n",
        "            matic_received = get_matic_received_from_txn(sell_receipt)  # Extract MATIC received\n",
        "\n",
        "            if matic_received > 0:\n",
        "                      # Step 2: Calculate the 1% tax from the MATIC received\n",
        "                tax_amount = matic_received * Decimal('0.5')\n",
        "\n",
        "                      # Step 3: Transfer the 1% tax to the tax wallet\n",
        "                tax_txn_hash = transfer_tax(user_id, matic_received, tax_amount)\n",
        "\n",
        "            else:\n",
        "              bot.send_message(call.message.chat.id, \"No MATIC received from the sell transaction.\")\n",
        "\n",
        "        # Optionally, after selling, remove the position from user data and refresh the positions\n",
        "        remove_position(user_id, token_address)\n",
        "        show_positions(call.message)\n",
        "\n",
        "    elif call.data.startswith(\"remove_position_\"):\n",
        "      token_address = call.data.split(\"_\")[2]\n",
        "      remove_position(user_id, token_address)\n",
        "      show_positions(call.message)  # Reopen the positions menu\n",
        "\n",
        "    if call.data == \"back_to_start\":\n",
        "        # Delete the current wallet screen\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)\n",
        "\n",
        "        # Send the welcome/start screen\n",
        "        send_welcome(call.message)\n",
        "\n",
        "    #----------------------------------------------------------------------------------------------------------------------------------------\n",
        "    #Wallet Settings\n",
        "\n",
        "    elif call.data == \"deposit_pol\":\n",
        "        wallet_address = user_wallets[user_id]['address']\n",
        "        bot.send_message(call.message.chat.id, f\"To deposit, send POL to the address seen here:\\n\\n{wallet_address}\", parse_mode=\"Markdown\")\n",
        "\n",
        "    if call.data == \"withdraw_x_pol\":\n",
        "        # Step 1: Ask for the destination wallet address\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the previous message\n",
        "        msg = bot.send_message(call.message.chat.id, \"Please enter the destination wallet address:\")\n",
        "        bot.register_next_step_handler(msg, process_withdraw_address)\n",
        "\n",
        "    elif call.data == \"confirm_withdraw\":\n",
        "        # Handle the actual withdrawal process\n",
        "        destination_address = user_wallets[user_id]['withdraw_address']\n",
        "        amount_to_withdraw = user_wallets[user_id]['withdraw_amount']\n",
        "        private_key = user_wallets[user_id]['private_key']\n",
        "\n",
        "        # Add withdrawal logic here\n",
        "        txn_hash = withdraw_pol(private_key, destination_address, amount_to_withdraw)\n",
        "\n",
        "        # Send feedback to the user\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the previous message\n",
        "        if isinstance(txn_hash, str) and txn_hash.startswith(\"0x\"):\n",
        "            bot.send_message(call.message.chat.id, f\"Withdrawal successful! Transaction Hash: {txn_hash}\")\n",
        "        else:\n",
        "            bot.send_message(call.message.chat.id, f\"Withdrawal failed: {txn_hash}\")\n",
        "\n",
        "    elif call.data == \"cancel_withdraw\":\n",
        "        # Handle withdrawal cancellation\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the previous message\n",
        "        bot.send_message(call.message.chat.id, \"Withdrawal has been canceled.\")\n",
        "        show_wallet_info(user_id, call.message.chat.id)  # Return to the wallet info screen\n",
        "\n",
        "    if call.data == \"export_private_key\":\n",
        "    # Step 1: Show a warning message and ask for confirmation\n",
        "      markup = InlineKeyboardMarkup()\n",
        "      confirm_button = InlineKeyboardButton(\"✅ Yes, Proceed\", callback_data=\"confirm_export_private_key\")\n",
        "      cancel_button = InlineKeyboardButton(\"❌ Cancel\", callback_data=\"cancel_export_private_key\")\n",
        "      markup.add(confirm_button, cancel_button)\n",
        "\n",
        "      warning_message = (\n",
        "          \"⚠️ *WARNING!* ⚠️\\n\\n\"\n",
        "          \"Revealing your private key poses a security risk, as it will be shown in plain text. To safeguard your assets, ensure no one can view or capture your screen while you retrieve the key.\\n\\n\"\n",
        "          \"*Do you wish to proceed?*\"\n",
        "      )\n",
        "\n",
        "      bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the previous message\n",
        "      bot.send_message(call.message.chat.id, warning_message, parse_mode=\"Markdown\", reply_markup=markup)\n",
        "\n",
        "    elif call.data == \"confirm_export_private_key\":\n",
        "        # Step 2: Display the private key if the user confirms\n",
        "        private_key = user_wallets[user_id]['private_key']\n",
        "\n",
        "        # Create markup with a \"Go Back\" button\n",
        "        markup = InlineKeyboardMarkup()\n",
        "        go_back_button = InlineKeyboardButton(\"🔙 Go Back\", callback_data=\"wallet\")\n",
        "        markup.add(go_back_button)\n",
        "\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the previous message\n",
        "        bot.send_message(call.message.chat.id,\n",
        "                        f\"Your private key is: {private_key}\",\n",
        "                        parse_mode=\"Markdown\",\n",
        "                        reply_markup=markup)\n",
        "\n",
        "    elif call.data == \"cancel_export_private_key\":\n",
        "        # Handle cancellation by going back to the wallet screen\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)  # Delete the previous message\n",
        "        show_wallet_info(user_id, call.message.chat.id)  # Return to the wallet info screen\n",
        "\n",
        "#-------------------------------------------------------------------------------------------------------\n",
        "#settings handling\n",
        "\n",
        "     # Handle the \"Configure Swap Presets\" button press\n",
        "     # Handle swap preset configuration\n",
        "    elif call.data == \"configure_swap_presets\":\n",
        "        # Use the new function to generate the preset menu\n",
        "        markup = create_preset_menu(user_id)\n",
        "\n",
        "        # Send the message with the current presets\n",
        "        bot.send_message(call.message.chat.id, \"🛠 *Configure Swap Presets*\\n\\nChoose a preset to modify:\", reply_markup=markup, parse_mode=\"Markdown\")\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)\n",
        "\n",
        "\n",
        "    elif call.data.startswith(\"edit_preset_buy_\"):\n",
        "      # Safely split the callback data and handle the correct part\n",
        "      parts = call.data.split(\"_\")\n",
        "\n",
        "      # Print the parts of the callback data for debugging\n",
        "      print(f\"Callback data parts: {parts}\")\n",
        "\n",
        "      # Check if the fourth part (index) is a digit before proceeding\n",
        "      if len(parts) > 3 and parts[3].isdigit():\n",
        "          preset_index = int(parts[3])  # Get the preset index as an integer\n",
        "\n",
        "          # Fetch swap presets from the user's data\n",
        "          swap_presets = user_wallets.get(user_id, {}).get('swap_presets', [10, 20, 30, 40, 50])\n",
        "          selected_preset = swap_presets[preset_index]\n",
        "\n",
        "          # Ask the user to input the new preset value\n",
        "          msg = bot.send_message(call.message.chat.id, f\"Current preset: {selected_preset} MATIC\\nPlease enter a new value:\")\n",
        "          bot.register_next_step_handler(msg, process_new_buy_preset, preset_index)\n",
        "      else:\n",
        "          # Handle invalid data format\n",
        "          bot.send_message(call.message.chat.id, \"Invalid callback data. Could not process preset edit request.\")\n",
        "\n",
        "    elif call.data.startswith(\"edit_preset_sell_\"):\n",
        "      parts = call.data.split(\"_\")\n",
        "\n",
        "      # Ensure the correct parts of the callback are present and valid\n",
        "      if len(parts) == 4 and parts[3].isdigit():\n",
        "          preset_index = int(parts[3])  # Extract the preset index\n",
        "          msg = bot.send_message(call.message.chat.id, f\"Enter a new sell percentage for Preset {preset_index + 1}:\")\n",
        "          bot.register_next_step_handler(msg, process_new_sell_preset, preset_index)\n",
        "      else:\n",
        "          bot.send_message(call.message.chat.id, \"Invalid callback data for preset editing.\")\n",
        "\n",
        "\n",
        "    # Handle the back_to_settings callback\n",
        "    elif call.data == \"back_to_settings\":\n",
        "        # Go back to the settings menu\n",
        "        show_settings_menu(user_id, call.message.chat.id)\n",
        "        bot.delete_message(call.message.chat.id, call.message.message_id)\n",
        "#-----------------------------------------------------------------------------------------------------'=\n",
        " # Handle \"Slippage Settings\" callback\n",
        "    # Handle \"Slippage Settings\" callback\n",
        "    if call.data == \"slippage_settings\":\n",
        "        # Fetch current slippage percentages (default to 1% for buy and sell)\n",
        "        buy_slippage = user_wallets.get(user_id, {}).get('buy_slippage', 1)\n",
        "        sell_slippage = user_wallets.get(user_id, {}).get('sell_slippage', 1)\n",
        "\n",
        "        # Display options for buy and sell slippage\n",
        "        markup = InlineKeyboardMarkup()\n",
        "        buy_slippage_button = InlineKeyboardButton(f\"Buy Slippage ({buy_slippage}%)\", callback_data=\"set_buy_slippage\")\n",
        "        sell_slippage_button = InlineKeyboardButton(f\"Sell Slippage ({sell_slippage}%)\", callback_data=\"set_sell_slippage\")\n",
        "        back_button = InlineKeyboardButton(\"🔙 Back\", callback_data=\"back_to_settings\")\n",
        "\n",
        "        markup.add(buy_slippage_button)\n",
        "        markup.add(sell_slippage_button)\n",
        "        markup.add(back_button)\n",
        "\n",
        "        bot.send_message(call.message.chat.id, \"Please select which slippage to configure:\", reply_markup=markup)\n",
        "\n",
        "    # Handle \"Buy Slippage\" configuration\n",
        "    elif call.data == \"set_buy_slippage\":\n",
        "        msg = bot.send_message(call.message.chat.id, \"Please enter your desired buy slippage percentage (e.g., 1.5):\")\n",
        "        bot.register_next_step_handler(msg, process_buy_slippage, call)\n",
        "\n",
        "    # Process the custom buy slippage input\n",
        "    elif call.data == \"set_sell_slippage\":\n",
        "        msg = bot.send_message(call.message.chat.id, \"Please enter your desired sell slippage percentage (e.g., 1.5):\")\n",
        "        bot.register_next_step_handler(msg, process_sell_slippage, call)\n",
        "\n",
        "    # Back to settings menu\n",
        "    elif call.data == \"back_to_settings\":\n",
        "        show_settings_menu(user_id, call.message.chat.id)\n",
        "\n",
        "# Functions for processing buy and sell slippage\n",
        "def process_buy_slippage(message, call):\n",
        "    user_id = str(message.chat.id)\n",
        "    try:\n",
        "        # Get the custom buy slippage percentage from the user's input\n",
        "        buy_slippage = float(message.text.strip())\n",
        "\n",
        "        # Validate input\n",
        "        if buy_slippage <= 0 or buy_slippage > 100:\n",
        "            raise ValueError(\"Slippage must be between 0.1% and 100%.\")\n",
        "\n",
        "        # Update the user's buy slippage percentage\n",
        "        user_wallets[user_id]['buy_slippage'] = buy_slippage\n",
        "        save_user_data()  # Save the custom buy slippage\n",
        "\n",
        "        bot.send_message(message.chat.id, f\"Buy slippage set to {buy_slippage}%.\")\n",
        "\n",
        "        # Return to slippage settings menu\n",
        "        show_settings_menu(user_id, message.chat.id)  # Updated to use the correct function\n",
        "\n",
        "    except ValueError:\n",
        "        bot.send_message(message.chat.id, \"Invalid input. Please enter a valid percentage (e.g., 1.5).\")\n",
        "\n",
        "    except ValueError:\n",
        "        bot.send_message(message.chat.id, \"Invalid input. Please enter a valid percentage (e.g., 1.5).\")\n",
        "\n",
        "def process_sell_slippage(message, call):\n",
        "    user_id = str(message.chat.id)\n",
        "    try:\n",
        "        # Get the custom sell slippage percentage from the user's input\n",
        "        sell_slippage = float(message.text.strip())\n",
        "\n",
        "        # Validate input\n",
        "        if sell_slippage <= 0 or sell_slippage > 100:\n",
        "            raise ValueError(\"Slippage must be between 0.1% and 100%.\")\n",
        "\n",
        "        # Update the user's sell slippage percentage\n",
        "        user_wallets[user_id]['sell_slippage'] = sell_slippage\n",
        "        save_user_data()  # Save the custom sell slippage\n",
        "\n",
        "        bot.send_message(message.chat.id, f\"Sell slippage set to {sell_slippage}%.\")\n",
        "\n",
        "        # Return to settings menu after successfully setting slippage\n",
        "        show_settings_menu(user_id, message.chat.id)  # Updated to use the correct function\n",
        "\n",
        "    except ValueError:\n",
        "        bot.send_message(message.chat.id, \"Invalid input. Please enter a valid percentage (e.g., 1.5).\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "def create_preset_menu(user_id):\n",
        "    swap_presets = user_wallets.get(user_id, {}).get('swap_presets', [10, 20, 30, 40, 50])\n",
        "    sell_presets = user_wallets.get(user_id, {}).get('sell_presets', [25, 50])\n",
        "\n",
        "    # Create the preset configuration menu\n",
        "    markup = types.InlineKeyboardMarkup()\n",
        "\n",
        "    buy_label_button = types.InlineKeyboardButton(\"---- Buy Settings ----\", callback_data=\"settings_label\")\n",
        "    markup.row(buy_label_button)\n",
        "\n",
        "    # Labels for buttons: Top Left, Top Center, Top Right, and so on\n",
        "    button_labels = [\n",
        "        \"Top Left\", \"Top Center\", \"Top Right\",\n",
        "        \"Middle Left\", \"Middle Center\", \"Middle Right\",\n",
        "        \"Bottom Left\", \"Bottom Center\", \"Bottom Right\"\n",
        "    ]\n",
        "\n",
        "    # Explicitly add each button on its own row\n",
        "    for i, preset in enumerate(swap_presets):\n",
        "        label = button_labels[i] if i < len(button_labels) else f\"Preset {i + 1}\"\n",
        "        button = types.InlineKeyboardButton(f\"{label}: {preset} POL\", callback_data=f\"edit_preset_buy_{i}\")\n",
        "        markup.row(button)  # Ensure each button is added as a separate row\n",
        "\n",
        "    # Add a back button at the bottom\n",
        "    back_button = types.InlineKeyboardButton(\"🔙 Back\", callback_data=\"back_to_settings\")\n",
        "    markup.row(back_button)\n",
        "\n",
        "    return markup\n",
        "\n",
        "\n",
        "def get_matic_received_from_txn(sell_receipt):\n",
        "    logs = sell_receipt['logs']\n",
        "    matic_received = 0\n",
        "\n",
        "    for log in logs:\n",
        "        # Check if this log corresponds to receiving MATIC (WETH equivalent on Polygon)\n",
        "        if 'address' in log and log['address'].lower() == wmatic_address.lower():\n",
        "            try:\n",
        "                # Attempt to convert the log's data to an integer, which represents the MATIC received (in wei)\n",
        "                log_data = log['data']\n",
        "                # Ensure the log data is in the right format and length before converting\n",
        "                if isinstance(log_data, str) and len(log_data) > 2 and log_data.startswith('0x'):\n",
        "                    matic_received += int(log_data, 16)  # Convert from hex string to integer\n",
        "                elif isinstance(log_data, bytes):\n",
        "                    matic_received += int.from_bytes(log_data, byteorder='big')  # Convert from bytes to integer\n",
        "            except ValueError as e:\n",
        "                print(f\"Failed to parse log data: {str(e)}\")\n",
        "\n",
        "    # Convert received amount from wei to MATIC\n",
        "    return web3.from_wei(matic_received, 'ether')\n",
        "\n",
        "\n",
        "def process_new_buy_preset(message, preset_index):\n",
        "    user_id = str(message.chat.id)\n",
        "    try:\n",
        "        new_value = float(message.text.strip())\n",
        "\n",
        "        # Update the user's presets\n",
        "        if 'swap_presets' not in user_wallets[user_id]:\n",
        "            user_wallets[user_id]['swap_presets'] = [10, 20, 30, 40, 50]  # Default presets\n",
        "\n",
        "        user_wallets[user_id]['swap_presets'][preset_index] = new_value\n",
        "        save_user_data()  # Save the updated presets\n",
        "\n",
        "        # Inform the user that the preset was updated\n",
        "        bot.send_message(message.chat.id, f\"Preset {preset_index + 1} updated to {new_value} MATIC.\")\n",
        "\n",
        "        # Use the new function to generate the preset menu\n",
        "        markup = create_preset_menu(user_id)\n",
        "\n",
        "        # Send the updated preset menu\n",
        "        bot.send_message(message.chat.id, \"🛠 *Configure Swap Presets*\\n\\nChoose a preset to modify:\", reply_markup=markup, parse_mode=\"Markdown\")\n",
        "\n",
        "    except ValueError:\n",
        "        # Handle invalid input\n",
        "        bot.send_message(message.chat.id, \"Invalid input. Please enter a numeric value.\")\\\n",
        "\n",
        "def process_new_sell_preset(message, preset_index):\n",
        "    user_id = str(message.chat.id)\n",
        "    try:\n",
        "        new_value = float(message.text.strip())\n",
        "\n",
        "        # Validate the new percentage\n",
        "        if new_value <= 0 or new_value > 100:\n",
        "            bot.send_message(message.chat.id, \"Invalid percentage. Please enter a value between 1 and 100.\")\n",
        "            return\n",
        "\n",
        "        # Update the user's sell presets\n",
        "        if 'sell_presets' not in user_wallets[user_id]:\n",
        "            user_wallets[user_id]['sell_presets'] = [25, 50]  # Default sell percentages\n",
        "\n",
        "        # Update the specific sell preset\n",
        "        user_wallets[user_id]['sell_presets'][preset_index] = new_value\n",
        "        save_user_data()  # Save the updated presets\n",
        "\n",
        "        # Inform the user that the preset was updated\n",
        "        bot.send_message(message.chat.id, f\"Sell Preset {preset_index + 1} updated to {new_value} %.\")\n",
        "\n",
        "        # Regenerate the preset menu with updated values\n",
        "        markup = create_preset_menu(user_id)\n",
        "        bot.send_message(message.chat.id, \"🛠 *Configure Swap Presets*\\n\\nChoose a preset to modify:\", reply_markup=markup, parse_mode=\"Markdown\")\n",
        "\n",
        "    except ValueError:\n",
        "        bot.send_message(message.chat.id, \"Invalid input. Please enter a numeric value.\")\n",
        "\n",
        "\n",
        "\n",
        "def process_withdraw_address(message):\n",
        "    # Step 2: Validate the address and ask for the amount\n",
        "    user_id = str(message.chat.id)\n",
        "    destination_address = message.text.strip()\n",
        "\n",
        "    if Web3.is_address(destination_address):\n",
        "        # Delete the previous message before proceeding\n",
        "        bot.delete_message(message.chat.id, message.message_id)\n",
        "\n",
        "        # Store the valid address temporarily in user_wallets\n",
        "        user_wallets[user_id]['withdraw_address'] = destination_address\n",
        "        msg = bot.send_message(message.chat.id, \"How much POL would you like to send?\")\n",
        "        bot.register_next_step_handler(msg, process_withdraw_amount)\n",
        "    else:\n",
        "        # Invalid address, prompt again\n",
        "        bot.send_message(message.chat.id, \"Invalid wallet address. Please enter a valid Polygon wallet address.\")\n",
        "        return\n",
        "\n",
        "def process_withdraw_amount(message):\n",
        "    # Step 3: Ask for confirmation after the user inputs the amount\n",
        "    user_id = str(message.chat.id)\n",
        "    try:\n",
        "        amount_to_withdraw = float(message.text.strip())\n",
        "\n",
        "        # Delete the previous message before proceeding\n",
        "        bot.delete_message(message.chat.id, message.message_id)\n",
        "\n",
        "        user_wallets[user_id]['withdraw_amount'] = amount_to_withdraw\n",
        "\n",
        "        # Step 4: Ask for confirmation\n",
        "        markup = InlineKeyboardMarkup()\n",
        "        confirm_button = InlineKeyboardButton(\"✅ Yes\", callback_data=\"confirm_withdraw\")\n",
        "        cancel_button = InlineKeyboardButton(\"❌ No\", callback_data=\"cancel_withdraw\")\n",
        "        markup.add(confirm_button, cancel_button)\n",
        "\n",
        "        # Display confirmation message\n",
        "        bot.send_message(\n",
        "          message.chat.id,\n",
        "          f\"<b>Amount:</b> {amount_to_withdraw:.4f} POL\\n\\n\"\n",
        "          f\"<b>Recipient:</b> {user_wallets[user_id]['withdraw_address']}\\n\\n\"\n",
        "          f\"<b>Are you sure?</b>\",\n",
        "          reply_markup=markup,\n",
        "          parse_mode='HTML'\n",
        "      )\n",
        "\n",
        "    except ValueError:\n",
        "        # If the user enters an invalid amount\n",
        "        bot.send_message(message.chat.id, \"Invalid amount entered. Please enter a valid number.\")\n",
        "        return\n",
        "\n",
        "def withdraw_pol(private_key, destination_address, amount):\n",
        "    # Use from_key to derive the wallet address from the private key\n",
        "    account = web3.eth.account.from_key(private_key)\n",
        "    wallet_address = account.address\n",
        "    nonce = web3.eth.get_transaction_count(wallet_address)\n",
        "    gas_price = web3.eth.gas_price\n",
        "\n",
        "    # Build transaction for sending POL (MATIC)\n",
        "    try:\n",
        "        transaction = {\n",
        "            'nonce': nonce,\n",
        "            'to': destination_address,\n",
        "            'value': web3.to_wei(amount, 'ether'),  # The amount of POL (MATIC) to send, converted to wei\n",
        "            'gas': 21000,  # Standard gas limit for a simple transfer\n",
        "            'gasPrice': gas_price,\n",
        "            'chainId': 137  # Polygon mainnet chain ID\n",
        "        }\n",
        "\n",
        "        # Sign the transaction with the user's private key\n",
        "        signed_txn = web3.eth.account.sign_transaction(transaction, private_key)\n",
        "\n",
        "        # Send the signed transaction\n",
        "        txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)\n",
        "        return web3.to_hex(txn_hash)\n",
        "    except ValueError as e:\n",
        "        # Handle Web3-related errors\n",
        "        return f\"Withdrawal failed: {str(e)}\"\n",
        "    except Exception as e:\n",
        "        # Log additional details for debugging\n",
        "        return f\"An unexpected error occurred: {e.args[0]}\"\n",
        "\n",
        "\n",
        "\n",
        "def process_custom_sell_percentage_with_tax(message, token_address):\n",
        "    user_id = str(message.chat.id)  # Use message.chat.id for user ID\n",
        "    percentage_text = message.text.strip()  # Use message.text to get the custom percentage input\n",
        "\n",
        "    try:\n",
        "        # Ensure the input is a valid float and between 0 and 100\n",
        "        custom_percentage = float(percentage_text)\n",
        "        if custom_percentage <= 0 or custom_percentage > 100:\n",
        "            raise ValueError(\"Percentage must be between 1 and 100.\")\n",
        "\n",
        "        # Send a \"Sell Pending\" message\n",
        "        bot.send_message(message.chat.id, \"Sell Pending 🟡\")\n",
        "\n",
        "        # Call the sell_percent function with the custom percentage\n",
        "        sell_receipt = sell_percent(user_id, token_address, custom_percentage)\n",
        "\n",
        "        # Check if sell_receipt is a string (error) or a transaction receipt (successful)\n",
        "        if isinstance(sell_receipt, str):\n",
        "            # If it's a string, it's an error message\n",
        "            bot.send_message(message.chat.id, f\"Sell failed: {sell_receipt}\")\n",
        "        else:\n",
        "            # If it's a receipt, extract and display the transaction hash\n",
        "            txn_hash = sell_receipt.transactionHash  # Extract the transaction hash from the receipt\n",
        "            bot.send_message(message.chat.id, f\"Sell successful! Transaction Hash: {txn_hash.hex()}\")\n",
        "\n",
        "            # Step 1: Calculate the amount of MATIC received from the sell\n",
        "            matic_received = get_matic_received_from_txn(sell_receipt)\n",
        "\n",
        "            if matic_received > 0:\n",
        "                # Step 2: Calculate the 1% tax from the MATIC received\n",
        "                tax_amount = matic_received * Decimal('0.5')\n",
        "\n",
        "                # Step 3: Transfer the 1% tax to the tax wallet\n",
        "                tax_txn_hash = transfer_tax(user_id, matic_received, tax_amount)\n",
        "\n",
        "            else:\n",
        "                bot.send_message(message.chat.id, \"No MATIC received from the sell transaction.\")\n",
        "\n",
        "            # Display the updated sell menu or return to the home menu\n",
        "            display_selling_menu(user_id, token_address)\n",
        "\n",
        "    except ValueError as ve:\n",
        "        # Handle invalid percentage input\n",
        "        bot.send_message(message.chat.id, f\"Invalid percentage: {str(ve)}. Please enter a valid number between 1 and 100.\")\n",
        "        print(f\"Error processing percentage: {str(ve)}\")\n",
        "\n",
        "    except Exception as e:\n",
        "        # Catch and display any other errors\n",
        "        bot.send_message(message.chat.id, f\"An error occurred: {str(e)}\")\n",
        "        print(f\"Error: {str(e)}\")\n",
        "\n",
        "\n",
        "def approve_token_for_sell(user_id, token_address):\n",
        "    wallet_info = user_wallets[user_id]\n",
        "    wallet_address = wallet_info['address']\n",
        "    private_key = wallet_info['private_key']\n",
        "\n",
        "    # Get the token contract and approve the router to spend the tokens\n",
        "    token_contract = web3.eth.contract(address=token_address, abi=[\n",
        "        {\n",
        "            \"constant\": False,\n",
        "            \"inputs\": [{\"name\": \"_spender\", \"type\": \"address\"}, {\"name\": \"_value\", \"type\": \"uint256\"}],\n",
        "            \"name\": \"approve\",\n",
        "            \"outputs\": [{\"name\": \"success\", \"type\": \"bool\"}],\n",
        "            \"type\": \"function\"\n",
        "        }\n",
        "    ])\n",
        "\n",
        "    # Approve the router to spend tokens\n",
        "    approve_txn = token_contract.functions.approve(\n",
        "        router_contract_address, web3.to_wei(9999999, 'ether')  # Approve max amount for selling\n",
        "    ).build_transaction({\n",
        "        'from': wallet_address,\n",
        "        'gas': 100000,\n",
        "        'gasPrice': web3.to_wei('90', 'gwei'),\n",
        "        'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "        'chainId': 137  # Polygon mainnet\n",
        "    })\n",
        "\n",
        "    try:\n",
        "        signed_approve_txn = web3.eth.account.sign_transaction(approve_txn, private_key)\n",
        "        approve_txn_hash = web3.eth.send_raw_transaction(signed_approve_txn.raw_transaction)\n",
        "        web3.eth.wait_for_transaction_receipt(approve_txn_hash)\n",
        "        return approve_txn_hash.hex()\n",
        "    except Exception as e:\n",
        "        print(f\"Approval failed: {str(e)}\")\n",
        "        return None\n",
        "\n",
        "def transfer_tax(user_id, token_address, matic_amount):\n",
        "    wallet_info = user_wallets[user_id]\n",
        "    wallet_address = wallet_info['address']\n",
        "    private_key = wallet_info['private_key']\n",
        "\n",
        "    matic_amount = float(matic_amount)\n",
        "\n",
        "    # Calculate 1% tax\n",
        "    tax_amount = matic_amount * 0.01\n",
        "\n",
        "    # Transfer the 1% tax to the tax wallet\n",
        "    tax_txn = {\n",
        "        'from': wallet_address,\n",
        "        'to': tax_wallet_address,\n",
        "        'value': web3.to_wei(tax_amount, 'ether'),\n",
        "        'gas': 21000,\n",
        "        'gasPrice': web3.eth.gas_price,\n",
        "        'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "        'chainId': 137  # Polygon Mainnet\n",
        "    }\n",
        "\n",
        "    try:\n",
        "        signed_tax_txn = web3.eth.account.sign_transaction(tax_txn, private_key)\n",
        "        tax_txn_hash = web3.eth.send_raw_transaction(signed_tax_txn.raw_transaction)\n",
        "        web3.eth.wait_for_transaction_receipt(tax_txn_hash)\n",
        "        return tax_txn_hash.hex()\n",
        "    except Exception as e:\n",
        "        print(f\"Tax transaction failed: {str(e)}\")\n",
        "        return None\n",
        "\n",
        "\n",
        "\n",
        "# Function to remove the position\n",
        "def remove_position(user_id, token_address):\n",
        "    user_wallets[user_id]['positions'] = [\n",
        "        position for position in user_wallets[user_id]['positions'] if position['token_address'] != token_address\n",
        "    ]\n",
        "    save_user_data()  # Save the updated wallet data\n",
        "\n",
        "\n",
        "def ask_for_confirmation(message, token_address):\n",
        "    user_id = str(message.chat.id)  # Make sure user_id is always a string\n",
        "    matic_amount_text = message.text.strip()\n",
        "\n",
        "    try:\n",
        "        # Ensure the input is a valid float and greater than zero\n",
        "        matic_amount = float(matic_amount_text)\n",
        "        if matic_amount <= 0:\n",
        "            raise ValueError(\"Amount must be greater than zero.\")\n",
        "\n",
        "        # Ensure the user has a wallet\n",
        "        if user_id not in user_wallets:\n",
        "            bot.send_message(message.chat.id, \"You don't have a wallet yet. Please type /start to create one.\")\n",
        "            return\n",
        "\n",
        "        # Store the amount and token address in a temporary dictionary\n",
        "        user_wallets[user_id]['pending_swap'] = {'matic_amount': matic_amount, 'token_address': token_address}\n",
        "\n",
        "        # Ask for confirmation\n",
        "        markup = InlineKeyboardMarkup()\n",
        "        confirm_button = InlineKeyboardButton(\"Confirm\", callback_data=\"confirm_swap\")\n",
        "        cancel_button = InlineKeyboardButton(\"Cancel\", callback_data=\"cancel_swap\")\n",
        "        markup.add(confirm_button, cancel_button)\n",
        "\n",
        "        bot.send_message(message.chat.id, f\"You are about to swap {matic_amount:.6f} MATIC for the token. Confirm?\", reply_markup=markup)\n",
        "\n",
        "    except ValueError as ve:\n",
        "        # Handle invalid MATIC input\n",
        "        bot.send_message(message.chat.id, f\"Invalid amount: {str(ve)}. Please enter a valid number.\")\n",
        "        print(f\"Error processing MATIC amount: {str(ve)}\")\n",
        "\n",
        "    except Exception as e:\n",
        "        # Catch and display any other errors\n",
        "        bot.send_message(message.chat.id, f\"An error occurred: {str(e)}\")\n",
        "        print(f\"Error: {str(e)}\")\n",
        "\n",
        "\n",
        "\n",
        "def process_custom_matic_amount(message, token_address):\n",
        "    user_id = message.chat.id\n",
        "    matic_amount_text = message.text.strip()\n",
        "\n",
        "    try:\n",
        "        # Ensure the input is a valid float and greater than zero\n",
        "        matic_amount = float(matic_amount_text)\n",
        "        if matic_amount <= 0:\n",
        "            raise ValueError(\"Amount must be greater than zero.\")\n",
        "\n",
        "        # Log the MATIC amount for debugging\n",
        "        print(f\"User {user_id} wants to swap {matic_amount} MATIC for token at address {token_address}\")\n",
        "\n",
        "        # Proceed to perform the swap\n",
        "        txn_hash = swap_matic_for_tokens(user_id, token_address, matic_amount)\n",
        "\n",
        "        if txn_hash:\n",
        "            bot.send_message(message.chat.id, f\"Swap successful! Transaction Hash: {txn_hash}\")\n",
        "\n",
        "            # Fetch and display the new token balance after the swap\n",
        "            balance = get_token_balance(user_wallets[user_id]['address'], token_address)\n",
        "            bot.send_message(message.chat.id, f\"Your new token balance: {balance:.6f}\")\n",
        "        else:\n",
        "            bot.send_message(message.chat.id, \"Swap failed. Please try again.\")\n",
        "\n",
        "    except ValueError as ve:\n",
        "        # Handle invalid MATIC input\n",
        "        bot.send_message(message.chat.id, f\"Invalid amount: {str(ve)}. Please enter a valid number.\")\n",
        "        print(f\"Error processing MATIC amount: {str(ve)}\")\n",
        "\n",
        "    except Exception as e:\n",
        "        # Catch and display any other errors\n",
        "        bot.send_message(message.chat.id, f\"Swap failed: {str(e)}\")\n",
        "        print(f\"Swap failed with error: {str(e)}\")\n",
        "\n",
        "\n",
        "def prompt_matic_amount(message, token_address=None):\n",
        "    user_id = str(message.chat.id)\n",
        "\n",
        "    # Ensure the user has a wallet\n",
        "    if user_id not in user_wallets:\n",
        "        bot.send_message(message.chat.id, \"You don't have a wallet yet. Please type /start to create one.\")\n",
        "        return\n",
        "\n",
        "    if not token_address:\n",
        "        token_address = message.text.strip()\n",
        "\n",
        "    # Get token information\n",
        "    token_info = get_token_info(token_address)\n",
        "\n",
        "    if token_info:\n",
        "        # Escape special characters for MarkdownV2\n",
        "        token_name = escape_markdown_v2(token_info['name'])\n",
        "        token_address_escaped = escape_markdown_v2(token_address)\n",
        "        fdv = escape_markdown_v2(token_info['fdv'])\n",
        "        price = escape_markdown_v2(f\"{float(token_info['price']):,.6f}\")\n",
        "        liquidity = escape_markdown_v2(token_info['liquidity'])\n",
        "        dex = escape_markdown_v2(token_info['dex'])\n",
        "\n",
        "        # Format the token information\n",
        "        info_message = (\n",
        "            f\"*{token_name} \\\\(Polygon\\\\)*\\n\"\n",
        "            f\"{token_address_escaped}\\n\\n\"\n",
        "            f\"Pool Info:\\n\"\n",
        "            f\"DEX: {dex}\\n\"\n",
        "            f\"MC: {fdv}\\n\"\n",
        "            f\"Price: ${price}\\n\"\n",
        "            f\"Liquidity: {liquidity}\\n\\n\"\n",
        "            \"Please select the amount of MATIC to swap:\"\n",
        "        )\n",
        "\n",
        "        # Avoid sending duplicate messages by checking flow\n",
        "        if user_wallets[user_id].get('pending_message_sent', False):\n",
        "            return\n",
        "\n",
        "        # Store that the message has been sent to prevent duplicates\n",
        "        user_wallets[user_id]['pending_message_sent'] = True\n",
        "\n",
        "        # Fetch the user's custom swap presets (default to [10, 20, 30, 40, 50] if not set)\n",
        "        swap_presets = user_wallets[user_id].get('swap_presets', [10, 20, 30, 40, 50])\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        refresh_button = InlineKeyboardButton(\"🔄 Refresh\", callback_data=\"refresh\")\n",
        "        cancel_button = InlineKeyboardButton(\"❌ Cancel\", callback_data=\"cancel\")\n",
        "\n",
        "        markup = InlineKeyboardMarkup()\n",
        "\n",
        "        row1 = []\n",
        "        for preset in swap_presets[:3]:  # First 3 buttons\n",
        "            row1.append(InlineKeyboardButton(f\"Buy {preset} POL\", callback_data=f\"swap_{preset}_{token_address}\"))\n",
        "        markup.row(*row1)\n",
        "\n",
        "        # Add buttons in the second row (4, 5, X)\n",
        "        row2 = []\n",
        "        for preset in swap_presets[3:5]:  # Next 2 buttons\n",
        "            row2.append(InlineKeyboardButton(f\"Buy {preset} POL\", callback_data=f\"swap_{preset}_{token_address}\"))\n",
        "        row2.append(InlineKeyboardButton(\"Buy X POL\", callback_data=f\"swap_X_{token_address}\"))  # \"Buy X MATIC\" button\n",
        "        markup.row(*row2)\n",
        "\n",
        "        markup.add(cancel_button, refresh_button)\n",
        "\n",
        "        bot.send_message(message.chat.id, info_message, reply_markup=markup, parse_mode=\"MarkdownV2\")\n",
        "\n",
        "        # Reset the flag after sending the message\n",
        "        user_wallets[user_id]['pending_message_sent'] = False\n",
        "    else:\n",
        "        info_message = \"Failed to retrieve token information. Please check the contract address and try again.\"\n",
        "        bot.send_message(message.chat.id, info_message, parse_mode=\"MarkdownV2\")\n",
        "\n",
        "def display_selling_menu(user_id, token_address):\n",
        "    # Ensure the user has positions before attempting to access them\n",
        "    if user_id not in user_wallets or not user_wallets[user_id]['positions']:\n",
        "        bot.send_message(user_id, \"You have no positions to display the sell menu.\")\n",
        "        return\n",
        "\n",
        "    token_info = get_token_info(token_address)\n",
        "    if token_info:\n",
        "        token_name = escape_markdown_v2(token_info['name'])  # Escape special characters\n",
        "        token_address_escaped = escape_markdown_v2(token_address)  # Escape special characters\n",
        "        fdv = escape_markdown_v2(token_info['fdv'])\n",
        "        price = escape_markdown_v2(f\"{float(token_info['price']):,.6f}\")\n",
        "        dex = escape_markdown_v2(token_info['dex'])  # Escape special characters\n",
        "\n",
        "        # Format liquidity as integer without decimals, removing commas first\n",
        "        if token_info['liquidity'] != \"N/A\":\n",
        "            liquidity_cleaned = token_info['liquidity'].replace(',', '')  # Remove commas\n",
        "            liquidity_formatted = escape_markdown_v2(f\"{int(float(liquidity_cleaned)):,}\")  # Convert to int and format with commas\n",
        "        else:\n",
        "            liquidity_formatted = \"N/A\"\n",
        "\n",
        "        # Retrieve the user's token balance\n",
        "        wallet_address = user_wallets[user_id]['address']\n",
        "        token_balance = get_token_balance(wallet_address, token_address)\n",
        "\n",
        "        # Retrieve initial MATIC cost from stored data\n",
        "        initial_cost_matic = None\n",
        "        for position in user_wallets[user_id]['positions']:\n",
        "            if isinstance(position, dict) and position.get('token_address') == token_address:\n",
        "                initial_cost_matic = position.get('cost_in_matic')  # Get the MATIC spent\n",
        "                break\n",
        "\n",
        "        # If initial MATIC cost is available, calculate PnL and worth\n",
        "        if initial_cost_matic:\n",
        "            current_worth_matic = token_balance * float(token_info['price'])  # Current worth in MATIC\n",
        "            pnl = ((current_worth_matic - initial_cost_matic) / initial_cost_matic) * 100  # Profit/Loss percentage\n",
        "\n",
        "            # Escape the numeric values and special characters\n",
        "            pnl_message = (\n",
        "                f\"Profit: {escape_markdown_v2(f'{int(pnl)}%')}\\n\"\n",
        "                f\"Worth: {escape_markdown_v2(f'{int(current_worth_matic)}')} MATIC \\\\| \"\n",
        "                f\"Cost: {escape_markdown_v2(f'{int(initial_cost_matic)}')} MATIC\\n\"\n",
        "                f\"Tokens: {escape_markdown_v2(f'{int(token_balance)}')}\"\n",
        "            )\n",
        "        else:\n",
        "            pnl_message = f\"Tokens: {escape_markdown_v2(f'{int(token_balance)}')}\\n\"\n",
        "\n",
        "        # Format the token information with bold text for the token name and chain\n",
        "        info_message = (\n",
        "            f\"*{token_name} \\\\(Polygon\\\\)*\\n\"\n",
        "            f\"{token_address_escaped}\\n\\n\"\n",
        "            f\"Pool Info:\\n\"\n",
        "            f\"DEX: {dex}\\n\"\n",
        "            f\"MC: ${fdv}\\n\"\n",
        "            f\"Price: {price}\\n\"\n",
        "            f\"Liquidity: ${liquidity_formatted}\\n\\n\"\n",
        "            f\"{pnl_message}\\n\\n\"\n",
        "            \"Please select the amount of MATIC to swap:\"\n",
        "        )\n",
        "\n",
        "        # Create inline buttons\n",
        "\n",
        "        swap_presets = user_wallets[user_id].get('swap_presets', [10, 20, 30, 40, 50])\n",
        "\n",
        "        markup = InlineKeyboardMarkup()\n",
        "\n",
        "        row2 = []\n",
        "        for preset in swap_presets[3:5]:  # Next 2 buttons\n",
        "            row2.append(InlineKeyboardButton(f\"Buy {preset} POL\", callback_data=f\"swap_{preset}_{token_address}\"))\n",
        "        row2.append(InlineKeyboardButton(\"Buy X POL\", callback_data=f\"swap_X_{token_address}\"))  # \"Buy X MATIC\" button\n",
        "        markup.row(*row2)\n",
        "\n",
        "        prev_button = InlineKeyboardButton(\"⬅️ Prev\", callback_data=\"cycle_-1\")\n",
        "        token_button = InlineKeyboardButton(token_name, callback_data=\"ticker\")\n",
        "        next_button = InlineKeyboardButton(\"Next ➡️\", callback_data=\"cycle_1\")\n",
        "        markup.add(prev_button, token_button, next_button)\n",
        "\n",
        "        sell_x = InlineKeyboardButton(\"Sell X%\", callback_data=f\"sell_X_{token_address}\")\n",
        "\n",
        "        sell_presets = user_wallets.get(user_id, {}).get('sell_presets', [25, 50])\n",
        "\n",
        "        # Create two preset buttons in one row\n",
        "        if len(sell_presets) >= 2:\n",
        "            sell_25_button = InlineKeyboardButton(f\"Sell {sell_presets[0]}%\", callback_data=f\"sell_{sell_presets[0]}_{token_address}\")\n",
        "            sell_50_button = InlineKeyboardButton(f\"Sell {sell_presets[1]}%\", callback_data=f\"sell_{sell_presets[1]}_{token_address}\")\n",
        "            markup.row(sell_25_button, sell_50_button, sell_x)  # Add them in the same row\n",
        "\n",
        "\n",
        "\n",
        "        full_100 = InlineKeyboardButton(\"Sell Full Bag\", callback_data=f\"full_100_{token_address}\")\n",
        "\n",
        "        remove_position = InlineKeyboardButton(\"🗑️ Remove Position\", callback_data=f\"remove_position_{token_address}\")\n",
        "        refresh_button = InlineKeyboardButton(\"🔄 Refresh\", callback_data=f\"refresh_{token_address}\")\n",
        "        cancel_button = InlineKeyboardButton(\"❌ Cancel\", callback_data=\"cancel\")\n",
        "\n",
        "        # Add buttons to the markup\n",
        "\n",
        "\n",
        "        markup.add(full_100)\n",
        "        markup.add(refresh_button)\n",
        "        markup.add(remove_position, cancel_button)\n",
        "\n",
        "        # Send the message\n",
        "        bot.send_message(user_id, info_message, reply_markup=markup, parse_mode=\"MarkdownV2\")\n",
        "    else:\n",
        "        bot.send_message(user_id, \"Failed to retrieve token information for sell menu.\")\n",
        "\n",
        "\n",
        "def cycle_position(message, user_id, direction):\n",
        "    # Ensure that user_positions contains data for the user\n",
        "    if user_id not in user_wallets or not user_wallets[user_id]['positions']:\n",
        "        bot.send_message(message.chat.id, \"You have no positions to cycle through.\")\n",
        "        return\n",
        "\n",
        "    # Get the list of positions (token addresses) for the user\n",
        "    token_list = user_wallets[user_id]['positions']\n",
        "\n",
        "    # Ensure token_list has positions before proceeding\n",
        "    if not token_list:\n",
        "        bot.send_message(message.chat.id, \"No tokens in your positions.\")\n",
        "        return\n",
        "\n",
        "    # Get the current index or default to 0 if not present\n",
        "    current_index = user_wallets[user_id].get('current_position_index', 0)\n",
        "\n",
        "    # Calculate the new index with cycling logic (handle wrap-around using modulo)\n",
        "    new_index = (current_index + direction) % len(token_list)\n",
        "\n",
        "    # Update the current position index for the user\n",
        "    user_wallets[user_id]['current_position_index'] = new_index\n",
        "\n",
        "    # Display the token info for the new position (passing the token address)\n",
        "    display_selling_menu(user_id, token_list[new_index]['token_address'])\n",
        "\n",
        "\n",
        "def show_positions(message):\n",
        "    user_id = str(message.chat.id)\n",
        "\n",
        "    if user_id not in user_wallets or not user_wallets[user_id]['positions']:\n",
        "        bot.send_message(message.chat.id, \"You have no positions.\")\n",
        "        return\n",
        "\n",
        "    positions_message = \"📊 Your Positions:\\n\\n\"\n",
        "    markup = InlineKeyboardMarkup()\n",
        "\n",
        "    # Iterate over positions and extract the token address from the dictionary\n",
        "    for position in user_wallets[user_id]['positions']:\n",
        "        token_address = position['token_address']  # Ensure we are only passing the token address string\n",
        "        token_info = get_token_info(token_address)  # Fetch token info\n",
        "        token_name = token_info['name'] if token_info else token_address\n",
        "        token_balance = get_token_balance(user_wallets[user_id]['address'], token_address)\n",
        "        positions_message += f\"{token_name}: {token_balance:.6f}\\n\"\n",
        "\n",
        "        # Add a button for each token that triggers the sell menu\n",
        "        token_button = InlineKeyboardButton(token_name, callback_data=f\"selling_menu_{token_address}\")\n",
        "        markup.add(token_button)\n",
        "\n",
        "    bot.send_message(message.chat.id, positions_message, reply_markup=markup)\n",
        "\n",
        "commands = [\n",
        "    BotCommand(\"start\", \"Start using the bot\"),\n",
        "    BotCommand(\"settings\", \"Open the settings menu\"),\n",
        "    BotCommand(\"help\", \"Get help\")\n",
        "]\n",
        "\n",
        "# Set the command menu\n",
        "bot.set_my_commands(commands)\n",
        "\n",
        "# Start polling for messages\n",
        "bot.polling()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "vsQWyb9tVRqe"
      },
      "outputs": [],
      "source": [
        "from google.colab import drive\n",
        "drive.mount('/content/drive')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 4,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "Yi4jE3Ol1lt4",
        "outputId": "b1c9ecf8-25ab-425d-a951-c77175ec9b3a"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Collecting pyTelegramBotAPI\n",
            "  Downloading pytelegrambotapi-4.22.1-py3-none-any.whl.metadata (48 kB)\n",
            "\u001b[?25l     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m0.0/48.2 kB\u001b[0m \u001b[31m?\u001b[0m eta \u001b[36m-:--:--\u001b[0m\r\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m48.2/48.2 kB\u001b[0m \u001b[31m3.3 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hRequirement already satisfied: requests in /usr/local/lib/python3.10/dist-packages (from pyTelegramBotAPI) (2.32.3)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests->pyTelegramBotAPI) (3.3.2)\n",
            "Requirement already satisfied: idna<4,>=2.5 in /usr/local/lib/python3.10/dist-packages (from requests->pyTelegramBotAPI) (3.8)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests->pyTelegramBotAPI) (2.0.7)\n",
            "Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests->pyTelegramBotAPI) (2024.8.30)\n",
            "Downloading pytelegrambotapi-4.22.1-py3-none-any.whl (261 kB)\n",
            "\u001b[?25l   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m0.0/261.0 kB\u001b[0m \u001b[31m?\u001b[0m eta \u001b[36m-:--:--\u001b[0m\r\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m261.0/261.0 kB\u001b[0m \u001b[31m15.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hInstalling collected packages: pyTelegramBotAPI\n",
            "Successfully installed pyTelegramBotAPI-4.22.1\n"
          ]
        }
      ],
      "source": [
        "pip install pyTelegramBotAPI\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "58H-sZtJ_6B5",
        "outputId": "1728ce84-9433-4f7d-87bf-dd35548d5e17"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "{\"5901674624\": {\"address\": \"0x6eB3416F80d3dFad67633A765bE6854eaEbfd0a9\", \"private_key\": \"f67f1f8a85173c6fb1f06be2306e15e6660672f1459b4f275582e33e2b98a1e3\", \"positions\": [], \"swap_presets\": [15.0, 20, 30, 40, 50], \"pending_message_sent\": false, \"pending_swap\": {\"matic_amount\": 10.0, \"token_address\": \"0x433cDE5a82b5e0658dA3543b47A375dffd126Eb6\"}, \"sell_presets\": [30.0, 50], \"withdraw_address\": \"0xDBDc6751153b0c7990901C5DE51EF9aBF0313cA2\", \"withdraw_amount\": 5.0}}"
          ]
        }
      ],
      "source": [
        "!cat user_data.json\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "J2Fgxkr4JEYY",
        "outputId": "5293d805-0433-4f53-e948-08fa6d071478"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Cleared the contents of /content/user_data.json\n"
          ]
        }
      ],
      "source": [
        "import json\n",
        "\n",
        "# Path to your JSON file\n",
        "USER_DATA_FILE = \"/content/user_data.json\"\n",
        "\n",
        "# Overwrite the file with an empty dictionary\n",
        "def clear_user_data():\n",
        "    with open(USER_DATA_FILE, 'w') as file:\n",
        "        json.dump({}, file)\n",
        "    print(f\"Cleared the contents of {USER_DATA_FILE}\")\n",
        "\n",
        "# Clear the JSON file\n",
        "clear_user_data()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "GQTIFv0-XNVR"
      },
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "O4z6ureFT0zb"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "sFwyLu52W1WA"
      },
      "outputs": [],
      "source": [
        "\"address\": \"0x6eB3416F80d3dFad67633A765bE6854eaEbfd0a9\", \"private_key\": \"f67f1f8a85173c6fb1f06be2306e15e6660672f1459b4f275582e33e2b98a1e3\""
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "gY43sYRH600Q"
      },
      "source": [
        "{\"5901674624\": {\"address\":\n",
        "\"0x6eB3416F80d3dFad67633A765bE6854eaEbfd0a9\", \"private_key\": \"f67f1f8a85173c6fb1f06be2306e15e6660672f1459b4f275582e33e2b98a1e3\", \"positions\": []}}\n",
        "\n",
        "> Add blockquote\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "gQbcaoHq60hc"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "XIwP77X5zATa"
      },
      "outputs": [],
      "source": [
        "def swap_tokens_for_matic(user_id, token_address):\n",
        "    wallet_info = user_wallets[user_id]\n",
        "    wallet_address = wallet_info['address']\n",
        "    private_key = wallet_info['private_key']\n",
        "\n",
        "    # Get the token contract\n",
        "    token_contract = web3.eth.contract(address=token_address, abi=[\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}],\n",
        "            \"name\": \"balanceOf\",\n",
        "            \"outputs\": [{\"name\": \"balance\", \"type\": \"uint256\"}],\n",
        "            \"type\": \"function\"\n",
        "        },\n",
        "        {\n",
        "            \"constant\": True,\n",
        "            \"inputs\": [],\n",
        "            \"name\": \"decimals\",\n",
        "            \"outputs\": [{\"name\": \"\", \"type\": \"uint8\"}],\n",
        "            \"type\": \"function\"\n",
        "        },\n",
        "        {\n",
        "            \"constant\": False,\n",
        "            \"inputs\": [{\"name\": \"_spender\", \"type\": \"address\"}, {\"name\": \"_value\", \"type\": \"uint256\"}],\n",
        "            \"name\": \"approve\",\n",
        "            \"outputs\": [{\"name\": \"success\", \"type\": \"bool\"}],\n",
        "            \"type\": \"function\"\n",
        "        }\n",
        "    ])\n",
        "\n",
        "    # Get the user's token balance and decimals\n",
        "    token_balance = token_contract.functions.balanceOf(wallet_address).call()\n",
        "    decimals = token_contract.functions.decimals().call()\n",
        "    token_balance_in_wei = int(token_balance * (10 ** decimals))  # Convert balance to wei\n",
        "\n",
        "    # Set the deadline for the swap (10 minutes from now)\n",
        "    deadline = int(time.time()) + 600\n",
        "\n",
        "    # Step 1: Approve the router to spend the tokens\n",
        "    try:\n",
        "        approve_txn = token_contract.functions.approve(\n",
        "            router_contract_address,\n",
        "            token_balance_in_wei\n",
        "        ).build_transaction({\n",
        "            'from': wallet_address,\n",
        "            'gas': 100000,  # Fixed gas limit for approval\n",
        "            'gasPrice': web3.to_wei('90', 'gwei'),  # Fixed gas price\n",
        "            'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "            'chainId': 137  # Polygon mainnet chain ID\n",
        "        })\n",
        "\n",
        "        # Sign and send the approval transaction\n",
        "        signed_approve_txn = web3.eth.account.sign_transaction(approve_txn, private_key)\n",
        "        approve_txn_hash = web3.eth.send_raw_transaction(signed_approve_txn.raw_transaction)\n",
        "        web3.eth.wait_for_transaction_receipt(approve_txn_hash)\n",
        "        print(f\"Approval successful, transaction hash: {web3.to_hex(approve_txn_hash)}\")\n",
        "\n",
        "    except Exception as e:\n",
        "        return f\"Approval failed: {str(e)}\"\n",
        "\n",
        "    # Step 2: Perform the swap to sell the tokens for MATIC\n",
        "    try:\n",
        "        sell_txn = router_contract.functions.swapExactTokensForETH(\n",
        "            token_balance_in_wei,  # Amount of tokens to sell\n",
        "            0,  # Accept any amount of MATIC (no minimum)\n",
        "            [token_address, wmatic_address],  # Path: Token -> MATIC\n",
        "            wallet_address,  # Recipient address\n",
        "            deadline  # Deadline\n",
        "        ).build_transaction({\n",
        "            'from': wallet_address,\n",
        "            'gas': 200000,  # Fixed gas limit for the swap\n",
        "            'gasPrice': web3.to_wei('90', 'gwei'),  # Fixed gas price\n",
        "            'nonce': web3.eth.get_transaction_count(wallet_address),\n",
        "            'chainId': 137  # Polygon mainnet chain ID\n",
        "        })\n",
        "\n",
        "        # Sign and send the sell transaction\n",
        "        signed_sell_txn = web3.eth.account.sign_transaction(sell_txn, private_key)\n",
        "        sell_txn_hash = web3.eth.send_raw_transaction(signed_sell_txn.raw_transaction)\n",
        "        sell_receipt = web3.eth.wait_for_transaction_receipt(sell_txn_hash)\n",
        "\n",
        "        print(f\"Sell successful, transaction hash: {web3.to_hex(sell_txn_hash)}\")\n",
        "        return sell_receipt\n",
        "\n",
        "    except Exception as e:\n",
        "        return f\"Swap transaction failed: {str(e)}\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "t7zxv-6EqTbh"
      },
      "outputs": [],
      "source": [
        "if call.data.startswith(\"sell_100_\"):\n",
        "        token_address = call.data.split(\"_\")[2]\n",
        "\n",
        "        # Call the sell_token function to sell 100% of the tokens (only pass user_id and token_address)\n",
        "        sell_receipt = sell_token(user_id, token_address)\n",
        "\n",
        "        # Check if sell_receipt is a string (error) or a transaction receipt (successful)\n",
        "        if isinstance(sell_receipt, str):\n",
        "            # If it's a string, it's an error message\n",
        "            bot.send_message(call.message.chat.id, f\"Sell failed: {sell_receipt}\")\n",
        "        else:\n",
        "            # If it's a receipt, extract and display the transaction hash\n",
        "            txn_hash = sell_receipt.transactionHash  # Extract the transaction hash from the receipt\n",
        "            bot.send_message(call.message.chat.id, f\"Sell successful! Transaction Hash: {txn_hash.hex()}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "mBzSG3xegKwQ",
        "outputId": "103a2298-8731-4f6d-84fc-eea4c4f5ccf4"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "File not found\n"
          ]
        }
      ],
      "source": [
        "import json\n",
        "import os\n",
        "\n",
        "# Set the file path relative to your Colab working directory\n",
        "file_path = 'telegram/user_data.json'\n",
        "\n",
        "# Check if the file exists in the specified directory\n",
        "if os.path.exists(file_path):\n",
        "    # Open and load the JSON file\n",
        "    with open(file_path, 'r') as f:\n",
        "        user_data = json.load(f)\n",
        "\n",
        "    # Now user_data is a Python dictionary that you can use\n",
        "    print(user_data)\n",
        "else:\n",
        "    print(\"File not found\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "Wl7GtBKog5GD",
        "outputId": "e49b2d4b-94b3-4289-a838-6dfecaba9dc3"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n"
          ]
        }
      ],
      "source": [
        "from google.colab import drive\n",
        "drive.mount('/content/drive')\n"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "mount_file_id": "1e3WrRbSKUfHjYZuZi52QU17usrKl_DoJ",
      "authorship_tag": "ABX9TyM6KNRqSG11UNaL7cL6bALI",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}